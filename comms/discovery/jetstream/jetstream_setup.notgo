package jetstream

import (
	"log"
	"strings"
	"sync"

	"comms.audius.co/discovery/config"
	"comms.audius.co/discovery/rpcz"
	"github.com/avast/retry-go"
	"github.com/nats-io/nats.go"
)

var setupJetstreamOnce sync.Once

func todoJetstreamSetup() {

	// todo: should get a nats client

	var goodNatsUrls = []string{}
	var err error

	setupJetstreamOnce.Do(func() {
		// create nats client with valid connections
		goodNatsUrl := strings.Join(goodNatsUrls, ",")
		config.Logger.Debug("nats client urls: " + goodNatsUrl)

		// setup client + streams: kind of like a db migration step
		var nc *nats.Conn
		var jsc nats.JetStreamContext
		err = retry.Do(func() error {
			var err error
			nc, err = dialNatsUrl(goodNatsUrl)
			if err != nil {
				return err
			}

			jsc, err = nc.JetStream(nats.PublishAsyncMaxPending(256))
			if err != nil {
				return err
			}

			err = createJetstreamStreams(jsc)
			if err != nil {
				return err
			}
			return nil
		})

		if err != nil {
			log.Fatal(err)
		}

		// setup client
		err = createConsumer(jsc)
		if err != nil {
			log.Fatal(err)
		}

		// success
		jetstream.SetJetstreamContext(jsc)
	})
}

func createJetstreamStreams(jsc nats.JetStreamContext) error {

	streamInfo, err := jsc.AddStream(&nats.StreamConfig{
		Name:     config.GlobalStreamName,
		Subjects: []string{config.GlobalStreamSubject},
		Replicas: config.NatsReplicaCount,
		// DenyDelete: true,
		// DenyPurge:  true,
	})
	if err != nil {
		return err
	}

	config.Logger.Info("create stream", "strm", streamInfo)

	// create kv buckets
	_, err = jsc.CreateKeyValue(&nats.KeyValueConfig{
		Bucket:   config.PubkeystoreBucketName,
		Replicas: config.NatsReplicaCount,
	})
	if err != nil {
		return err
	}

	_, err = jsc.CreateKeyValue(&nats.KeyValueConfig{
		Bucket:   config.RateLimitRulesBucketName,
		Replicas: config.NatsReplicaCount,
	})
	if err != nil {
		return err
	}

	return nil
}

func createConsumer(jsc nats.JetStreamContext) error {

	// ------------------------------------------------------------------------------
	// TEMP: Subscribe to the subject for the demo
	// this is the "processor" for DM messages... which just inserts them into comm log table for now
	// it assumes that nats message has the signature header
	// but this is not the case for identity relay messages, for instance, which should have their own consumer
	// also, should be a pull consumer with explicit ack.
	// matrix-org/dendrite codebase has some nice examples to follow...

	sub, err := jsc.Subscribe(config.GlobalStreamSubject, rpcz.Apply, nats.Durable(config.WalletAddress))

	if info, err := sub.ConsumerInfo(); err == nil {
		config.Logger.Info("create subscription", "sub", info)
	}

	return err
}
