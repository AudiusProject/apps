const axios = require('axios')
const { promisify } = require('util')
const crypto = require('crypto')
const randomBytes = promisify(crypto.randomBytes)
const { Utils: LibsUtils } = require('@audius/libs')

const {
  parseCNodeResponse,
  ErrorServerError,
  ErrorBadRequest
} = require('../../apiHelpers')
const { recoverWallet, signatureHasExpired } = require('../../apiSigning')

/**
 * This function is part of the L2 UserReplicaSetManager contract (URSM) chain of trust node registration flow.
 *    A requesting node submits a request for signature to self (proposer node) which it uses to submit as
 *    part of the contract addOrUpdateContentNode transaction.
 *
 * Steps:
 *  1. Fetch node info from L1 ServiceProviderFactory for spID
 *    a. Reject if node is not registered as valid SP
 *    b. Short circuit if L2 record for node already matches L1 record (i.e. delegateOwnerWallets match)
 *  2. Confirm request was signed by delegate owner wallet registered on L1 for spID, given request signature artifacts
 *  3. Confirm SP is within valid stake bounds on L1 ServiceProviderFactory
 *  4. Confirm health check returns healthy and response data matches on-chain data
 *    a. Confirm health check response was signed by delegate owner wallet registered on L1 for spID
 *  5. Generate & return proposal signature artifacts
 *
 * @param {ServiceRegistry} serviceRegistry
 * @param {*} logger
 * @param {number} spID L1 spID of requesting node, used by self (proposer node) in validation
 * @param {string} reqTimestamp timestamp when reqSignature was generated, used in public key recovery
 * @param {string} reqSignature signature generated by requesting node, used in public key recovery
 */
const respondToURSMRequestForSignature = async ({ libs: audiusLibs, nodeConfig }, logger, spID, reqTimestamp, reqSignature) => {
  spID = validateSPId(spID)

  const {
    ownerWalletFromSPFactory,
    delegateOwnerWalletFromSPFactory,
    nodeEndpointFromSPFactory
  } = await getSPInfo(audiusLibs, spID)

  await verifyRequesterIsValidSP({
    audiusLibs,
    spID,
    reqTimestamp,
    reqSignature,
    ownerWalletFromSPFactory,
    delegateOwnerWalletFromSPFactory,
    nodeEndpointFromSPFactory
  })

  /**
   * Short-circuit if L2 record already matches L1 record (i.e. delegateOwnerWallets match)
   */
  const delegateOwnerWalletFromURSM = (
    (await audiusLibs.contracts.UserReplicaSetManagerClient.getContentNodeWallets(spID))
      .delegateOwnerWallet
  ).toLowerCase()
  if (delegateOwnerWalletFromSPFactory === delegateOwnerWalletFromURSM) {
    throw new ErrorBadRequest(
      `No-op - UserReplicaSetManager record for node with spID ${spID} already matches L1 ServiceProviderFactory record`
    )
  }

  /**
   * Confirm service provider is within valid stake bounds on L1 ServiceProviderFactory
   */
  const spDetailsFromSPFactory = await audiusLibs.ethContracts.ServiceProviderFactoryClient.getServiceProviderDetails(
    ownerWalletFromSPFactory
  )
  if (!spDetailsFromSPFactory.validBounds) {
    throw new ErrorBadRequest('ServiceProvider for given spID is not within valid bounds on L1 ServiceProviderFactory')
  }

  /**
   * Request node's up-to-date health info
   *  - uses endpoint registered on L1 for spID
   *  - passes `randomBytesToSign` string in request to check that response was signed for provided data
   */
  const randomBytesToSign = (await randomBytes(18)).toString()
  const nodeHealthCheckResp = await axios({
    baseURL: nodeEndpointFromSPFactory,
    url: '/health_check',
    method: 'get',
    timeout: 1000,
    params: {
      randomBytesToSign
    }
  })
  const { responseData, signatureData } = parseCNodeResponse(
    nodeHealthCheckResp,
    ['healthy', 'creatorNodeEndpoint', 'spID', 'spOwnerWallet', 'randomBytesToSign']
  )

  /**
   * Confirm health check returns healthy and response data matches on-chain data
   */
  if (
    !(responseData.healthy) ||
    (responseData.creatorNodeEndpoint !== nodeEndpointFromSPFactory) ||
    (responseData.spID !== spID) ||
    ((responseData.spOwnerWallet).toLowerCase() !== ownerWalletFromSPFactory.toLowerCase())
  ) {
    throw new ErrorServerError(
      `Content node health check response from endpoint ${nodeEndpointFromSPFactory} indicates unhealthy or misconfigured`
    )
  }

  /**
   * Confirm health check response was signed by delegate owner wallet registered on L1
   *    for spID and includes `randomBytesToSign`
   */
  const {
    timestamp,
    signature,
    signer
  } = signatureData
  if (signatureHasExpired(timestamp)) {
    throw new ErrorBadRequest('Health check response signature has expired')
  }
  const responderWalletRecoveryObj = {
    data: responseData,
    signer,
    timestamp
  }
  const recoveredDelegateOwnerWallet2 = (recoverWallet(responderWalletRecoveryObj, signature)).toLowerCase()
  if (delegateOwnerWalletFromSPFactory !== recoveredDelegateOwnerWallet2) {
    throw new ErrorBadRequest(
      'Health check response must be signed by delegate owner wallet registered on L1 for spID'
    )
  }

  /**
   * Generate proposal signature artifacts
   */
  const proposalSignatureInfo = await audiusLibs.contracts.UserReplicaSetManagerClient.getProposeAddOrUpdateContentNodeRequestData(
    /* new node L1 spID */ spID,
    /* new node L1 delegateOwnerWallet */ delegateOwnerWalletFromSPFactory,
    /* proposing node (self) ownerWallet */ ownerWalletFromSPFactory,
    /* proposing node (self) L1 spID */ nodeConfig.get('spID')
  )

  return {
    nonce: proposalSignatureInfo.nonce,
    sig: proposalSignatureInfo.sig,
    spID: nodeConfig.get('spID') /* spID of self */
  }
}

/**
 * Fetch node info from L1 ServiceProviderFactory for spID
 * @param {Object} audiusLibs audius libs instance
 * @param {number} spID spId of the service provider currently observed
 * @returns data pertaining to the sp with the spID provided provided
 */
const getSPInfo = async (audiusLibs, spID) => {
  spID = validateSPId(spID)

  const spRecordFromSPFactory = await audiusLibs.ethContracts.ServiceProviderFactoryClient.getServiceEndpointInfo(
    'content-node',
    spID
  )

  let {
    owner: ownerWalletFromSPFactory,
    delegateOwnerWallet: delegateOwnerWalletFromSPFactory,
    endpoint: nodeEndpointFromSPFactory
  } = spRecordFromSPFactory
  delegateOwnerWalletFromSPFactory = delegateOwnerWalletFromSPFactory.toLowerCase()

  return {
    ownerWalletFromSPFactory,
    delegateOwnerWalletFromSPFactory,
    nodeEndpointFromSPFactory
  }
}

// Wrapper fn to perform basic validation that the requester is a valid SP and that the request
// came from the SP itself
const verifyRequesterIsValidSP = async ({
  audiusLibs,
  spID,
  reqTimestamp,
  reqSignature,
  ownerWalletFromSPFactory,
  delegateOwnerWalletFromSPFactory,
  nodeEndpointFromSPFactory
}) => {
  validateSPSignatureInfo(reqTimestamp, reqSignature)
  spID = validateSPId(spID)

  if (!ownerWalletFromSPFactory || !delegateOwnerWalletFromSPFactory) {
    throw new ErrorBadRequest(`Missing fields: ownerWallet=${ownerWalletFromSPFactory}, delegateOwnerWallet=${delegateOwnerWalletFromSPFactory}`)
  }

  /**
   * Reject if node is not registered as valid SP on L1 ServiceProviderFactory
   */
  if (
    LibsUtils.isZeroAddress(ownerWalletFromSPFactory) ||
    LibsUtils.isZeroAddress(delegateOwnerWalletFromSPFactory) ||
    !nodeEndpointFromSPFactory
  ) {
    throw new ErrorBadRequest(`SpID ${spID} is not registered as valid SP on L1 ServiceProviderFactory or missing field endpoint=${nodeEndpointFromSPFactory}`)
  }

  /**
   * Confirm request was signed by delegate owner wallet registered on L1 for spID, given request signature artifacts
   */
  let requesterWalletRecoveryObj = { spID, timestamp: reqTimestamp }
  let recoveredDelegateOwnerWallet = (recoverWallet(requesterWalletRecoveryObj, reqSignature)).toLowerCase()
  if (delegateOwnerWalletFromSPFactory !== recoveredDelegateOwnerWallet) {
    throw new ErrorBadRequest(
      'Request for signature must be signed by delegate owner wallet registered on L1 for spID'
    )
  }
}

/**
 * Validates the request query params used for verifying sp.
 * @param {string} reqTimestamp the timestamp off of the req query params
 * @param {string} reqSignature the signature off of the req query params
 */
function validateSPSignatureInfo (reqTimestamp, reqSignature) {
  if (!reqTimestamp || !reqSignature) {
    throw new ErrorBadRequest('Must provide all required query parameters: timestamp, signature')
  }
}

/**
 * Validates the request query param spID
 * @param {string} spID
 * @returns a parsed spID
 */
function validateSPId (spID) {
  if (!spID) {
    throw new ErrorBadRequest('Must provide all required query parameters: spID')
  }

  spID = parseInt(spID)

  if (isNaN(spID) || spID < 0) {
    throw new ErrorBadRequest(`Provided spID is not a valid id. spID=${spID}`)
  }

  return spID
}

module.exports = {
  respondToURSMRequestForSignature,
  verifyRequesterIsValidSP,
  getSPInfo,
  validateSPId
}
