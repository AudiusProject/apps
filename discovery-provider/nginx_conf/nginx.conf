# This config rate limits and redirect requests that exceed the rate limit to other discovery providers.

# The requests are rate limited by only allowing config.rate_limit requests every second to the discovery node; requests are redirected to other discovery nodes following this.

# To avoid infinite redirection, we set redirect_nonce, redirect_sig, and redirect_from when redirecting; the discovery provider receiving the redirect verifies this signature. We have a nonce to avoid an attacker from being able to get a valid redirect_sig since that could be used to focus a DDoS attack on a single node.

worker_processes 1;

error_log logs/error.log;

env audius_openresty_accept_redirect_from;
env audius_openresty_public_url;
env audius_openresty_rate_limit;
env audius_openresty_redirect_targets;
env audius_openresty_rsa_private_key;
env audius_openresty_rsa_public_key;

events {
    worker_connections 1024;
}

http {
    # set dns nginx should use for resolving external domains
    resolver 1.1.1.1;

    proxy_cache_path /usr/local/openresty/cache levels=1:2 keys_zone=cache:10m max_size=1g inactive=1m use_temp_path=off;

    lua_package_path "/usr/local/openresty/conf/?.lua;;";

    lua_shared_dict limit_count_store 100m;
    lua_shared_dict rsa_public_key_store 10m;
    lua_shared_dict nonce_store 10m;

    server {
        listen 5000;

        # remove redirect related params and store it in cache_args
        set $cache_args $args;

        if ($cache_args ~ (.*)(?:&|^)redirect_from=[^&]*(.*)) {
            set $cache_args $1$2;
        }

        if ($cache_args ~ (.*)(?:&|^)redirect_nonce=[^&]*(.*)) {
            set $cache_args $1$2;
        }

        if ($cache_args ~ (.*)(?:&|^)redirect_sig=[^&]*(.*)) {
            set $cache_args $1$2;
        }

        location = /openresty_pubkey {
            content_by_lua_block {
                local config = require "config"
                ngx.say(config.rsa_public_key)
            }
        }

        location = /health_check {
            content_by_lua_block {
                local main = require "main"
                local response = main.health_check()
                ngx.header.content_type = 'application/json'
                if not response then
                    ngx.status = 500
                    ngx.say('{"success": false}')
                    return
                end
                ngx.say(response)
            }
        }

        location ~* .*_(check|version) {
            proxy_pass http://127.0.0.1:3000;
        }

        location / {
            access_by_lua_block {
                local limit_count = require "resty.limit.count"

                local main = require "main"
                local config = require "config"

                if not config.rate_limiting_enabled then
                    return
                end

                if main.verify_signature(ngx.var.redirect_from, ngx.var.redirect_nonce, ngx.var.redirect_sig) then
                    return
                end

                -- limit_count.new(store, count, time_window in seconds)
                local lim, err = limit_count.new("limit_count_store", config.rate_limit, 1)
                if not lim then
                    ngx.log(ngx.ERR, "failed to instantiate a resty.limit.req object: ", err)
                    return ngx.exit(500)
                end

                -- set a dummy key since we are not rate limiting separately for each user
                -- lim:incoming(key, no_dry_run)
                local delay, err = lim:incoming("k", true)
                if not delay then
                    local rate_limit_hit = err == "rejected"
                    if rate_limit_hit then
                        -- Redirect request after setting redirect args
                        local args, err = ngx.req.get_uri_args()
                        args.redirect_from, args.redirect_nonce, args.redirect_sig = main.get_redirect_args()
                        ngx.req.set_uri_args(args)
                        local url = main.get_redirect_target() .. ngx.var.request_uri
                        return ngx.redirect(url)
                    end

                    ngx.log(ngx.ERR, "failed to limit req: ", err)
                    return ngx.exit(500)
                end
            }

            proxy_cache_key $scheme$proxy_host$uri$is_args$cache_args;
            proxy_cache_valid any 1m;
            proxy_cache cache;
            proxy_cache_revalidate on;
            proxy_cache_min_uses 3;
            proxy_cache_lock on;

            proxy_pass http://127.0.0.1:3000;
        }
    }
}
