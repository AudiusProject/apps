/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FollowingResponse } from '../model';
// @ts-ignore
import { FullPlaylistResponse } from '../model';
// @ts-ignore
import { FullTrendingPlaylistsResponse } from '../model';
/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch a playlist
        * @param {PlaylistsApiGetFullPlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullPlaylist: async ({  playlistId, }: PlaylistsApiGetFullPlaylistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'playlistId' is not null or undefined
            assertParamExists('getFullPlaylist', 'playlistId', playlistId)
            const localVarPath = `/playlists/{playlist_id}`
                .replace(`{${"playlist_id"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {PlaylistsApiGetUsersThatFavoritedAPlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersThatFavoritedAPlaylist: async ({  playlistId, userId, limit, offset, }: PlaylistsApiGetUsersThatFavoritedAPlaylistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'playlistId' is not null or undefined
            assertParamExists('getUsersThatFavoritedAPlaylist', 'playlistId', playlistId)
            const localVarPath = `/playlists/{playlist_id}/favorites`
                .replace(`{${"playlist_id"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {PlaylistsApiGetUsersThatRepostedAPlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersThatRepostedAPlaylist: async ({  playlistId, userId, limit, offset, }: PlaylistsApiGetUsersThatRepostedAPlaylistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'playlistId' is not null or undefined
            assertParamExists('getUsersThatRepostedAPlaylist', 'playlistId', playlistId)
            const localVarPath = `/playlists/{playlist_id}/reposts`
                .replace(`{${"playlist_id"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get trending playlists
        * @param {PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion: async ({  time, limit, offset, userId, }: PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersionRequest = {}, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/playlists/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get trending playlists
        * @param {PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1: async ({  version, time, limit, offset, userId, }: PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1', 'version', version)
            const localVarPath = `/playlists/trending/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch a playlist
         * @param {string} playlistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullPlaylist(playlistId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullPlaylistResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullPlaylist({ playlistId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [userId] A User ID
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersThatFavoritedAPlaylist(playlistId: string, userId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersThatFavoritedAPlaylist({ playlistId, userId, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [userId] A User ID
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersThatRepostedAPlaylist(playlistId: string, userId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersThatRepostedAPlaylist({ playlistId, userId, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get trending playlists
         * @param {string} [time] week / month / year
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {string} [userId] A User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion(time?: string, limit?: string, offset?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTrendingPlaylistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion({ time, limit, offset, userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get trending playlists
         * @param {string} version 
         * @param {string} [time] week / month / year
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {string} [userId] A User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1(version: string, time?: string, limit?: string, offset?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTrendingPlaylistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1({ version, time, limit, offset, userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch a playlist
         * @param {string} playlistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullPlaylist(playlistId: string, options?: any): AxiosPromise<FullPlaylistResponse> {
            return localVarFp.getFullPlaylist(playlistId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [userId] A User ID
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersThatFavoritedAPlaylist(playlistId: string, userId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<FollowingResponse> {
            return localVarFp.getUsersThatFavoritedAPlaylist(playlistId, userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [userId] A User ID
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersThatRepostedAPlaylist(playlistId: string, userId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<FollowingResponse> {
            return localVarFp.getUsersThatRepostedAPlaylist(playlistId, userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get trending playlists
         * @param {string} [time] week / month / year
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {string} [userId] A User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion(time?: string, limit?: string, offset?: string, userId?: string, options?: any): AxiosPromise<FullTrendingPlaylistsResponse> {
            return localVarFp.returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion(time, limit, offset, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get trending playlists
         * @param {string} version 
         * @param {string} [time] week / month / year
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {string} [userId] A User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1(version: string, time?: string, limit?: string, offset?: string, userId?: string, options?: any): AxiosPromise<FullTrendingPlaylistsResponse> {
            return localVarFp.returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1(version, time, limit, offset, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFullPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetFullPlaylistRequest
 */
export interface PlaylistsApiGetFullPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiGetFullPlaylist
     */
    readonly playlistId: string
}

/**
 * Request parameters for getUsersThatFavoritedAPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetUsersThatFavoritedAPlaylistRequest
 */
export interface PlaylistsApiGetUsersThatFavoritedAPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiGetUsersThatFavoritedAPlaylist
     */
    readonly playlistId: string

    /**
     * A User ID
     * @type {string}
     * @memberof PlaylistsApiGetUsersThatFavoritedAPlaylist
     */
    readonly userId?: string

    /**
     * Limit
     * @type {number}
     * @memberof PlaylistsApiGetUsersThatFavoritedAPlaylist
     */
    readonly limit?: number

    /**
     * Offset
     * @type {number}
     * @memberof PlaylistsApiGetUsersThatFavoritedAPlaylist
     */
    readonly offset?: number
}

/**
 * Request parameters for getUsersThatRepostedAPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetUsersThatRepostedAPlaylistRequest
 */
export interface PlaylistsApiGetUsersThatRepostedAPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiGetUsersThatRepostedAPlaylist
     */
    readonly playlistId: string

    /**
     * A User ID
     * @type {string}
     * @memberof PlaylistsApiGetUsersThatRepostedAPlaylist
     */
    readonly userId?: string

    /**
     * Limit
     * @type {number}
     * @memberof PlaylistsApiGetUsersThatRepostedAPlaylist
     */
    readonly limit?: number

    /**
     * Offset
     * @type {number}
     * @memberof PlaylistsApiGetUsersThatRepostedAPlaylist
     */
    readonly offset?: number
}

/**
 * Request parameters for returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersionRequest
 */
export interface PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersionRequest {
    /**
     * week / month / year
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion
     */
    readonly time?: string

    /**
     * Limit
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion
     */
    readonly limit?: string

    /**
     * Offset
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion
     */
    readonly offset?: string

    /**
     * A User ID
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion
     */
    readonly userId?: string
}

/**
 * Request parameters for returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1 operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0Request
 */
export interface PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0Request {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0
     */
    readonly version: string

    /**
     * week / month / year
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0
     */
    readonly time?: string

    /**
     * Limit
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0
     */
    readonly limit?: string

    /**
     * Offset
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0
     */
    readonly offset?: string

    /**
     * A User ID
     * @type {string}
     * @memberof PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0
     */
    readonly userId?: string
}

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch a playlist
     * @param {PlaylistsApiGetFullPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getFullPlaylist(requestParameters: PlaylistsApiGetFullPlaylistRequest, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getFullPlaylist(requestParameters.playlistId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaylistsApiGetUsersThatFavoritedAPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getUsersThatFavoritedAPlaylist(requestParameters: PlaylistsApiGetUsersThatFavoritedAPlaylistRequest, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getUsersThatFavoritedAPlaylist(requestParameters.playlistId, requestParameters.userId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaylistsApiGetUsersThatRepostedAPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getUsersThatRepostedAPlaylist(requestParameters: PlaylistsApiGetUsersThatRepostedAPlaylistRequest, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getUsersThatRepostedAPlaylist(requestParameters.playlistId, requestParameters.userId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get trending playlists
     * @param {PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion(requestParameters: PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersionRequest = {}, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion(requestParameters.time, requestParameters.limit, requestParameters.offset, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get trending playlists
     * @param {PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1(requestParameters: PlaylistsApiReturnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion0Request, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).returnsTrendingPlaylistsForATimePeriodBasedOnTheGivenTrendingVersion_1(requestParameters.version, requestParameters.time, requestParameters.limit, requestParameters.offset, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}
