/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FullTrackResponse } from '../model';
// @ts-ignore
import { FullTracksResponse } from '../model';
// @ts-ignore
import { RemixesResponseFull } from '../model';
// @ts-ignore
import { RemixingResponse } from '../model';
// @ts-ignore
import { StemsResponse } from '../model';
// @ts-ignore
import { TrackFavoritesResponseFull } from '../model';
// @ts-ignore
import { TrackRepostsResponseFull } from '../model';
// @ts-ignore
import { TrendingIdsResponse } from '../model';
/**
 * TracksApi - axios parameter creator
 * @export
 */
export const TracksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get track recommendations based on genre and trending
        * @param {TracksApiGetRecommendedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedTracks: async ({  genre, limit, exclusionList, time, userId, }: TracksApiGetRecommendedTracksRequest = {}, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/tracks/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (exclusionList) {
                localVarQueryParameter['exclusion_list'] = exclusionList;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get track recommendations based on genre and a specific trending version
        * @param {TracksApiGetRecommendedTracksWithVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedTracksWithVersion: async ({  version, genre, limit, exclusionList, time, userId, }: TracksApiGetRecommendedTracksWithVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getRecommendedTracksWithVersion', 'version', version)
            const localVarPath = `/tracks/recommended/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (exclusionList) {
                localVarQueryParameter['exclusion_list'] = exclusionList;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tracks that have stems and are available to remix
        * @param {TracksApiGetRemixableTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemixableTracks: async ({  userId, limit, withUsers, }: TracksApiGetRemixableTracksRequest = {}, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/tracks/remixables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (withUsers !== undefined) {
                localVarQueryParameter['with_users'] = withUsers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a track by its ID
        * @param {TracksApiGetTrackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrack: async ({  trackId, handle, urlTitle, showUnlisted, userId, }: TracksApiGetTrackRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getTrack', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (handle !== undefined) {
                localVarQueryParameter['handle'] = handle;
            }

            if (urlTitle !== undefined) {
                localVarQueryParameter['url_title'] = urlTitle;
            }

            if (showUnlisted !== undefined) {
                localVarQueryParameter['show_unlisted'] = showUnlisted;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users that favorited a track
        * @param {TracksApiGetTrackFavoritersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackFavoriters: async ({  trackId, userId, limit, offset, }: TracksApiGetTrackFavoritersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getTrackFavoriters', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/favorites`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the remixes of a track
        * @param {TracksApiGetTrackRemixesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackRemixes: async ({  trackId, userId, limit, offset, }: TracksApiGetTrackRemixesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getTrackRemixes', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/remixes`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the tracks this track remixes
        * @param {TracksApiGetTrackRemixingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackRemixing: async ({  trackId, userId, limit, offset, }: TracksApiGetTrackRemixingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getTrackRemixing', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/remixing`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users that reposted a track
        * @param {TracksApiGetTrackRepostersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackReposters: async ({  trackId, userId, limit, offset, }: TracksApiGetTrackRepostersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getTrackReposters', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/reposts`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the stems of the provided track
        * @param {TracksApiGetTrackStemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackStems: async ({  trackId, }: TracksApiGetTrackStemsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getTrackStems', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/stems`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets full tracks by their route/permalinks
        * @param {TracksApiGetTracksByRouteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracksByRoute: async ({  handle, slug, userId, route, }: TracksApiGetTracksByRouteRequest = {}, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/tracks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (handle !== undefined) {
                localVarQueryParameter['handle'] = handle;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (route) {
                localVarQueryParameter['route'] = route;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the track IDs of the top trending tracks on Audius
        * @param {TracksApiGetTrendingTrackIdsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingTrackIds: async ({  limit, genre, }: TracksApiGetTrendingTrackIdsRequest = {}, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/tracks/trending/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the track IDs of the top trending tracks on Audius using the specified trending version
        * @param {TracksApiGetTrendingTrackIdsWithVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingTrackIdsWithVersion: async ({  version, limit, genre, }: TracksApiGetTrendingTrackIdsWithVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getTrendingTrackIdsWithVersion', 'version', version)
            const localVarPath = `/tracks/trending/ids/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the top trending tracks on Audius
        * @param {TracksApiGetTrendingTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingTracks: async ({  genre, time, limit, offset, userId, }: TracksApiGetTrendingTracksRequest = {}, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/tracks/trending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the top trending tracks on Audius based on the trending version
        * @param {TracksApiGetTrendingTracksWithVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingTracksWithVersion: async ({  version, genre, time, limit, offset, userId, }: TracksApiGetTrendingTracksWithVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getTrendingTracksWithVersion', 'version', version)
            const localVarPath = `/tracks/trending/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (genre !== undefined) {
                localVarQueryParameter['genre'] = genre;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the trending tracks for underground artists
        * @param {TracksApiGetUndergroundTrendingTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUndergroundTrendingTracks: async ({  limit, offset, userId, }: TracksApiGetUndergroundTrendingTracksRequest = {}, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/tracks/trending/underground`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the trending tracks for underground artists using a specific trending calculator version
        * @param {TracksApiGetUndergroundTrendingTracksWithVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUndergroundTrendingTracksWithVersion: async ({  version, }: TracksApiGetUndergroundTrendingTracksWithVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getUndergroundTrendingTracksWithVersion', 'version', version)
            const localVarPath = `/tracks/trending/underground/{version}`
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TracksApi - functional programming interface
 * @export
 */
export const TracksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TracksApiAxiosParamCreator(configuration)
    return {
        /**
         * Get track recommendations based on genre and trending
         * @param {string} [genre] If specified, find recommended trending tracks for a specific genre
         * @param {number} [limit] Number of recommended tracks to fetch
         * @param {Array<number>} [exclusionList] Track IDs to exclude from the results
         * @param {'week' | 'month' | 'year'} [time] The timespan to get trending tracks
         * @param {string} [userId] The user ID of the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedTracks(genre?: string, limit?: number, exclusionList?: Array<number>, time?: 'week' | 'month' | 'year', userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedTracks({ genre, limit, exclusionList, time, userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get track recommendations based on genre and a specific trending version
         * @param {string} version The version of the trending calculation to use
         * @param {string} [genre] If specified, find recommended trending tracks for a specific genre
         * @param {number} [limit] Number of recommended tracks to fetch
         * @param {Array<number>} [exclusionList] Track IDs to exclude from the results
         * @param {'week' | 'month' | 'year'} [time] The timespan to get trending tracks
         * @param {string} [userId] The user ID of the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedTracksWithVersion(version: string, genre?: string, limit?: number, exclusionList?: Array<number>, time?: 'week' | 'month' | 'year', userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedTracksWithVersion({ version, genre, limit, exclusionList, time, userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets tracks that have stems and are available to remix
         * @param {string} [userId] The currently logged in user ID
         * @param {number} [limit] The number of items to fetch
         * @param {boolean} [withUsers] Whether the response should include full user objects (if false, only user IDs will be present)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemixableTracks(userId?: string, limit?: number, withUsers?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTrackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemixableTracks({ userId, limit, withUsers, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a track by its ID
         * @param {string} trackId the requested track id
         * @param {string} [handle] Handle of the track owner
         * @param {string} [urlTitle] The requested track slug
         * @param {boolean} [showUnlisted] Whether to include unlisted tracks
         * @param {string} [userId] The ID of the user making the request, to get contextual information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrack(trackId: string, handle?: string, urlTitle?: string, showUnlisted?: boolean, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTrackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrack({ trackId, handle, urlTitle, showUnlisted, userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get users that favorited a track
         * @param {string} trackId 
         * @param {string} [userId] The user ID of the logged in user
         * @param {number} [limit] The number of items to fetch
         * @param {number} [offset] Used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackFavoriters(trackId: string, userId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackFavoritesResponseFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackFavoriters({ trackId, userId, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the remixes of a track
         * @param {string} trackId 
         * @param {string} [userId] The currently logged in user ID
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackRemixes(trackId: string, userId?: string, limit?: string, offset?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemixesResponseFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackRemixes({ trackId, userId, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the tracks this track remixes
         * @param {string} trackId The track ID of the remix
         * @param {string} [userId] The currently logged in user ID
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackRemixing(trackId: string, userId?: string, limit?: string, offset?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemixingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackRemixing({ trackId, userId, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets users that reposted a track
         * @param {string} trackId The track ID
         * @param {string} [userId] The currently logged in user ID
         * @param {number} [limit] The number of items to fetch
         * @param {number} [offset] Used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackReposters(trackId: string, userId?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackRepostsResponseFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackReposters({ trackId, userId, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the stems of the provided track
         * @param {string} trackId The track ID of which to get stems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackStems(trackId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrackStems({ trackId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets full tracks by their route/permalinks
         * @param {string} [handle] (Deprecated) The handle of the track owner
         * @param {string} [slug] (Deprecated) The URLized title of the track
         * @param {string} [userId] The currently logged in user ID
         * @param {Array<string>} [route] The track\'s permalink (relatively pathed, eg. \"handle/slug\"
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTracksByRoute(handle?: string, slug?: string, userId?: string, route?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTrackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTracksByRoute({ handle, slug, userId, route, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the track IDs of the top trending tracks on Audius
         * @param {number} [limit] The number of items to fetch
         * @param {string} [genre] The genre to filter to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendingTrackIds(limit?: number, genre?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrendingIdsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendingTrackIds({ limit, genre, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the track IDs of the top trending tracks on Audius using the specified trending version
         * @param {string} version The verison of trending calculation to use
         * @param {number} [limit] The number of items to fetch
         * @param {string} [genre] The genre to filter to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendingTrackIdsWithVersion(version: string, limit?: number, genre?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrendingIdsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendingTrackIdsWithVersion({ version, limit, genre, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the top trending tracks on Audius
         * @param {string} [genre] The genre to filter to
         * @param {'week' | 'month' | 'year'} [time] The time range to find trending tracks
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {string} [userId] The currently logged in user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendingTracks(genre?: string, time?: 'week' | 'month' | 'year', limit?: string, offset?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendingTracks({ genre, time, limit, offset, userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the top trending tracks on Audius based on the trending version
         * @param {string} version The version of the trending strategy
         * @param {string} [genre] The genre to filter to
         * @param {'week' | 'month' | 'year'} [time] The time range to find trending tracks
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {string} [userId] The currently logged in user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrendingTracksWithVersion(version: string, genre?: string, time?: 'week' | 'month' | 'year', limit?: string, offset?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrendingTracksWithVersion({ version, genre, time, limit, offset, userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the trending tracks for underground artists
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {string} [userId] The currently logged in user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUndergroundTrendingTracks(limit?: string, offset?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUndergroundTrendingTracks({ limit, offset, userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the trending tracks for underground artists using a specific trending calculator version
         * @param {string} version The version of trending to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUndergroundTrendingTracksWithVersion(version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUndergroundTrendingTracksWithVersion({ version, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TracksApi - factory interface
 * @export
 */
export const TracksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TracksApiFp(configuration)
    return {
        /**
         * Get track recommendations based on genre and trending
         * @param {string} [genre] If specified, find recommended trending tracks for a specific genre
         * @param {number} [limit] Number of recommended tracks to fetch
         * @param {Array<number>} [exclusionList] Track IDs to exclude from the results
         * @param {'week' | 'month' | 'year'} [time] The timespan to get trending tracks
         * @param {string} [userId] The user ID of the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedTracks(genre?: string, limit?: number, exclusionList?: Array<number>, time?: 'week' | 'month' | 'year', userId?: string, options?: any): AxiosPromise<FullTracksResponse> {
            return localVarFp.getRecommendedTracks(genre, limit, exclusionList, time, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get track recommendations based on genre and a specific trending version
         * @param {string} version The version of the trending calculation to use
         * @param {string} [genre] If specified, find recommended trending tracks for a specific genre
         * @param {number} [limit] Number of recommended tracks to fetch
         * @param {Array<number>} [exclusionList] Track IDs to exclude from the results
         * @param {'week' | 'month' | 'year'} [time] The timespan to get trending tracks
         * @param {string} [userId] The user ID of the logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedTracksWithVersion(version: string, genre?: string, limit?: number, exclusionList?: Array<number>, time?: 'week' | 'month' | 'year', userId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRecommendedTracksWithVersion(version, genre, limit, exclusionList, time, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets tracks that have stems and are available to remix
         * @param {string} [userId] The currently logged in user ID
         * @param {number} [limit] The number of items to fetch
         * @param {boolean} [withUsers] Whether the response should include full user objects (if false, only user IDs will be present)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemixableTracks(userId?: string, limit?: number, withUsers?: boolean, options?: any): AxiosPromise<FullTrackResponse> {
            return localVarFp.getRemixableTracks(userId, limit, withUsers, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a track by its ID
         * @param {string} trackId the requested track id
         * @param {string} [handle] Handle of the track owner
         * @param {string} [urlTitle] The requested track slug
         * @param {boolean} [showUnlisted] Whether to include unlisted tracks
         * @param {string} [userId] The ID of the user making the request, to get contextual information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrack(trackId: string, handle?: string, urlTitle?: string, showUnlisted?: boolean, userId?: string, options?: any): AxiosPromise<FullTrackResponse> {
            return localVarFp.getTrack(trackId, handle, urlTitle, showUnlisted, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users that favorited a track
         * @param {string} trackId 
         * @param {string} [userId] The user ID of the logged in user
         * @param {number} [limit] The number of items to fetch
         * @param {number} [offset] Used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackFavoriters(trackId: string, userId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<TrackFavoritesResponseFull> {
            return localVarFp.getTrackFavoriters(trackId, userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the remixes of a track
         * @param {string} trackId 
         * @param {string} [userId] The currently logged in user ID
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackRemixes(trackId: string, userId?: string, limit?: string, offset?: string, options?: any): AxiosPromise<RemixesResponseFull> {
            return localVarFp.getTrackRemixes(trackId, userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the tracks this track remixes
         * @param {string} trackId The track ID of the remix
         * @param {string} [userId] The currently logged in user ID
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackRemixing(trackId: string, userId?: string, limit?: string, offset?: string, options?: any): AxiosPromise<RemixingResponse> {
            return localVarFp.getTrackRemixing(trackId, userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets users that reposted a track
         * @param {string} trackId The track ID
         * @param {string} [userId] The currently logged in user ID
         * @param {number} [limit] The number of items to fetch
         * @param {number} [offset] Used for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackReposters(trackId: string, userId?: string, limit?: number, offset?: number, options?: any): AxiosPromise<TrackRepostsResponseFull> {
            return localVarFp.getTrackReposters(trackId, userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the stems of the provided track
         * @param {string} trackId The track ID of which to get stems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackStems(trackId: string, options?: any): AxiosPromise<StemsResponse> {
            return localVarFp.getTrackStems(trackId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets full tracks by their route/permalinks
         * @param {string} [handle] (Deprecated) The handle of the track owner
         * @param {string} [slug] (Deprecated) The URLized title of the track
         * @param {string} [userId] The currently logged in user ID
         * @param {Array<string>} [route] The track\&#39;s permalink (relatively pathed, eg. \&quot;handle/slug\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracksByRoute(handle?: string, slug?: string, userId?: string, route?: Array<string>, options?: any): AxiosPromise<FullTrackResponse> {
            return localVarFp.getTracksByRoute(handle, slug, userId, route, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the track IDs of the top trending tracks on Audius
         * @param {number} [limit] The number of items to fetch
         * @param {string} [genre] The genre to filter to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingTrackIds(limit?: number, genre?: string, options?: any): AxiosPromise<TrendingIdsResponse> {
            return localVarFp.getTrendingTrackIds(limit, genre, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the track IDs of the top trending tracks on Audius using the specified trending version
         * @param {string} version The verison of trending calculation to use
         * @param {number} [limit] The number of items to fetch
         * @param {string} [genre] The genre to filter to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingTrackIdsWithVersion(version: string, limit?: number, genre?: string, options?: any): AxiosPromise<TrendingIdsResponse> {
            return localVarFp.getTrendingTrackIdsWithVersion(version, limit, genre, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the top trending tracks on Audius
         * @param {string} [genre] The genre to filter to
         * @param {'week' | 'month' | 'year'} [time] The time range to find trending tracks
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {string} [userId] The currently logged in user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingTracks(genre?: string, time?: 'week' | 'month' | 'year', limit?: string, offset?: string, userId?: string, options?: any): AxiosPromise<FullTracksResponse> {
            return localVarFp.getTrendingTracks(genre, time, limit, offset, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the top trending tracks on Audius based on the trending version
         * @param {string} version The version of the trending strategy
         * @param {string} [genre] The genre to filter to
         * @param {'week' | 'month' | 'year'} [time] The time range to find trending tracks
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {string} [userId] The currently logged in user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrendingTracksWithVersion(version: string, genre?: string, time?: 'week' | 'month' | 'year', limit?: string, offset?: string, userId?: string, options?: any): AxiosPromise<FullTracksResponse> {
            return localVarFp.getTrendingTracksWithVersion(version, genre, time, limit, offset, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the trending tracks for underground artists
         * @param {string} [limit] The number of items to fetch
         * @param {string} [offset] Used for pagination
         * @param {string} [userId] The currently logged in user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUndergroundTrendingTracks(limit?: string, offset?: string, userId?: string, options?: any): AxiosPromise<FullTracksResponse> {
            return localVarFp.getUndergroundTrendingTracks(limit, offset, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the trending tracks for underground artists using a specific trending calculator version
         * @param {string} version The version of trending to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUndergroundTrendingTracksWithVersion(version: string, options?: any): AxiosPromise<void> {
            return localVarFp.getUndergroundTrendingTracksWithVersion(version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRecommendedTracks operation in TracksApi.
 * @export
 * @interface TracksApiGetRecommendedTracksRequest
 */
export interface TracksApiGetRecommendedTracksRequest {
    /**
     * If specified, find recommended trending tracks for a specific genre
     * @type {string}
     * @memberof TracksApiGetRecommendedTracks
     */
    readonly genre?: string

    /**
     * Number of recommended tracks to fetch
     * @type {number}
     * @memberof TracksApiGetRecommendedTracks
     */
    readonly limit?: number

    /**
     * Track IDs to exclude from the results
     * @type {Array<number>}
     * @memberof TracksApiGetRecommendedTracks
     */
    readonly exclusionList?: Array<number>

    /**
     * The timespan to get trending tracks
     * @type {'week' | 'month' | 'year'}
     * @memberof TracksApiGetRecommendedTracks
     */
    readonly time?: 'week' | 'month' | 'year'

    /**
     * The user ID of the logged in user
     * @type {string}
     * @memberof TracksApiGetRecommendedTracks
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecommendedTracksWithVersion operation in TracksApi.
 * @export
 * @interface TracksApiGetRecommendedTracksWithVersionRequest
 */
export interface TracksApiGetRecommendedTracksWithVersionRequest {
    /**
     * The version of the trending calculation to use
     * @type {string}
     * @memberof TracksApiGetRecommendedTracksWithVersion
     */
    readonly version: string

    /**
     * If specified, find recommended trending tracks for a specific genre
     * @type {string}
     * @memberof TracksApiGetRecommendedTracksWithVersion
     */
    readonly genre?: string

    /**
     * Number of recommended tracks to fetch
     * @type {number}
     * @memberof TracksApiGetRecommendedTracksWithVersion
     */
    readonly limit?: number

    /**
     * Track IDs to exclude from the results
     * @type {Array<number>}
     * @memberof TracksApiGetRecommendedTracksWithVersion
     */
    readonly exclusionList?: Array<number>

    /**
     * The timespan to get trending tracks
     * @type {'week' | 'month' | 'year'}
     * @memberof TracksApiGetRecommendedTracksWithVersion
     */
    readonly time?: 'week' | 'month' | 'year'

    /**
     * The user ID of the logged in user
     * @type {string}
     * @memberof TracksApiGetRecommendedTracksWithVersion
     */
    readonly userId?: string
}

/**
 * Request parameters for getRemixableTracks operation in TracksApi.
 * @export
 * @interface TracksApiGetRemixableTracksRequest
 */
export interface TracksApiGetRemixableTracksRequest {
    /**
     * The currently logged in user ID
     * @type {string}
     * @memberof TracksApiGetRemixableTracks
     */
    readonly userId?: string

    /**
     * The number of items to fetch
     * @type {number}
     * @memberof TracksApiGetRemixableTracks
     */
    readonly limit?: number

    /**
     * Whether the response should include full user objects (if false, only user IDs will be present)
     * @type {boolean}
     * @memberof TracksApiGetRemixableTracks
     */
    readonly withUsers?: boolean
}

/**
 * Request parameters for getTrack operation in TracksApi.
 * @export
 * @interface TracksApiGetTrackRequest
 */
export interface TracksApiGetTrackRequest {
    /**
     * the requested track id
     * @type {string}
     * @memberof TracksApiGetTrack
     */
    readonly trackId: string

    /**
     * Handle of the track owner
     * @type {string}
     * @memberof TracksApiGetTrack
     */
    readonly handle?: string

    /**
     * The requested track slug
     * @type {string}
     * @memberof TracksApiGetTrack
     */
    readonly urlTitle?: string

    /**
     * Whether to include unlisted tracks
     * @type {boolean}
     * @memberof TracksApiGetTrack
     */
    readonly showUnlisted?: boolean

    /**
     * The ID of the user making the request, to get contextual information
     * @type {string}
     * @memberof TracksApiGetTrack
     */
    readonly userId?: string
}

/**
 * Request parameters for getTrackFavoriters operation in TracksApi.
 * @export
 * @interface TracksApiGetTrackFavoritersRequest
 */
export interface TracksApiGetTrackFavoritersRequest {
    /**
     * 
     * @type {string}
     * @memberof TracksApiGetTrackFavoriters
     */
    readonly trackId: string

    /**
     * The user ID of the logged in user
     * @type {string}
     * @memberof TracksApiGetTrackFavoriters
     */
    readonly userId?: string

    /**
     * The number of items to fetch
     * @type {number}
     * @memberof TracksApiGetTrackFavoriters
     */
    readonly limit?: number

    /**
     * Used for pagination
     * @type {number}
     * @memberof TracksApiGetTrackFavoriters
     */
    readonly offset?: number
}

/**
 * Request parameters for getTrackRemixes operation in TracksApi.
 * @export
 * @interface TracksApiGetTrackRemixesRequest
 */
export interface TracksApiGetTrackRemixesRequest {
    /**
     * 
     * @type {string}
     * @memberof TracksApiGetTrackRemixes
     */
    readonly trackId: string

    /**
     * The currently logged in user ID
     * @type {string}
     * @memberof TracksApiGetTrackRemixes
     */
    readonly userId?: string

    /**
     * The number of items to fetch
     * @type {string}
     * @memberof TracksApiGetTrackRemixes
     */
    readonly limit?: string

    /**
     * Used for pagination
     * @type {string}
     * @memberof TracksApiGetTrackRemixes
     */
    readonly offset?: string
}

/**
 * Request parameters for getTrackRemixing operation in TracksApi.
 * @export
 * @interface TracksApiGetTrackRemixingRequest
 */
export interface TracksApiGetTrackRemixingRequest {
    /**
     * The track ID of the remix
     * @type {string}
     * @memberof TracksApiGetTrackRemixing
     */
    readonly trackId: string

    /**
     * The currently logged in user ID
     * @type {string}
     * @memberof TracksApiGetTrackRemixing
     */
    readonly userId?: string

    /**
     * The number of items to fetch
     * @type {string}
     * @memberof TracksApiGetTrackRemixing
     */
    readonly limit?: string

    /**
     * Used for pagination
     * @type {string}
     * @memberof TracksApiGetTrackRemixing
     */
    readonly offset?: string
}

/**
 * Request parameters for getTrackReposters operation in TracksApi.
 * @export
 * @interface TracksApiGetTrackRepostersRequest
 */
export interface TracksApiGetTrackRepostersRequest {
    /**
     * The track ID
     * @type {string}
     * @memberof TracksApiGetTrackReposters
     */
    readonly trackId: string

    /**
     * The currently logged in user ID
     * @type {string}
     * @memberof TracksApiGetTrackReposters
     */
    readonly userId?: string

    /**
     * The number of items to fetch
     * @type {number}
     * @memberof TracksApiGetTrackReposters
     */
    readonly limit?: number

    /**
     * Used for pagination
     * @type {number}
     * @memberof TracksApiGetTrackReposters
     */
    readonly offset?: number
}

/**
 * Request parameters for getTrackStems operation in TracksApi.
 * @export
 * @interface TracksApiGetTrackStemsRequest
 */
export interface TracksApiGetTrackStemsRequest {
    /**
     * The track ID of which to get stems
     * @type {string}
     * @memberof TracksApiGetTrackStems
     */
    readonly trackId: string
}

/**
 * Request parameters for getTracksByRoute operation in TracksApi.
 * @export
 * @interface TracksApiGetTracksByRouteRequest
 */
export interface TracksApiGetTracksByRouteRequest {
    /**
     * (Deprecated) The handle of the track owner
     * @type {string}
     * @memberof TracksApiGetTracksByRoute
     */
    readonly handle?: string

    /**
     * (Deprecated) The URLized title of the track
     * @type {string}
     * @memberof TracksApiGetTracksByRoute
     */
    readonly slug?: string

    /**
     * The currently logged in user ID
     * @type {string}
     * @memberof TracksApiGetTracksByRoute
     */
    readonly userId?: string

    /**
     * The track\&#39;s permalink (relatively pathed, eg. \&quot;handle/slug\&quot;
     * @type {Array<string>}
     * @memberof TracksApiGetTracksByRoute
     */
    readonly route?: Array<string>
}

/**
 * Request parameters for getTrendingTrackIds operation in TracksApi.
 * @export
 * @interface TracksApiGetTrendingTrackIdsRequest
 */
export interface TracksApiGetTrendingTrackIdsRequest {
    /**
     * The number of items to fetch
     * @type {number}
     * @memberof TracksApiGetTrendingTrackIds
     */
    readonly limit?: number

    /**
     * The genre to filter to
     * @type {string}
     * @memberof TracksApiGetTrendingTrackIds
     */
    readonly genre?: string
}

/**
 * Request parameters for getTrendingTrackIdsWithVersion operation in TracksApi.
 * @export
 * @interface TracksApiGetTrendingTrackIdsWithVersionRequest
 */
export interface TracksApiGetTrendingTrackIdsWithVersionRequest {
    /**
     * The verison of trending calculation to use
     * @type {string}
     * @memberof TracksApiGetTrendingTrackIdsWithVersion
     */
    readonly version: string

    /**
     * The number of items to fetch
     * @type {number}
     * @memberof TracksApiGetTrendingTrackIdsWithVersion
     */
    readonly limit?: number

    /**
     * The genre to filter to
     * @type {string}
     * @memberof TracksApiGetTrendingTrackIdsWithVersion
     */
    readonly genre?: string
}

/**
 * Request parameters for getTrendingTracks operation in TracksApi.
 * @export
 * @interface TracksApiGetTrendingTracksRequest
 */
export interface TracksApiGetTrendingTracksRequest {
    /**
     * The genre to filter to
     * @type {string}
     * @memberof TracksApiGetTrendingTracks
     */
    readonly genre?: string

    /**
     * The time range to find trending tracks
     * @type {'week' | 'month' | 'year'}
     * @memberof TracksApiGetTrendingTracks
     */
    readonly time?: 'week' | 'month' | 'year'

    /**
     * The number of items to fetch
     * @type {string}
     * @memberof TracksApiGetTrendingTracks
     */
    readonly limit?: string

    /**
     * Used for pagination
     * @type {string}
     * @memberof TracksApiGetTrendingTracks
     */
    readonly offset?: string

    /**
     * The currently logged in user ID
     * @type {string}
     * @memberof TracksApiGetTrendingTracks
     */
    readonly userId?: string
}

/**
 * Request parameters for getTrendingTracksWithVersion operation in TracksApi.
 * @export
 * @interface TracksApiGetTrendingTracksWithVersionRequest
 */
export interface TracksApiGetTrendingTracksWithVersionRequest {
    /**
     * The version of the trending strategy
     * @type {string}
     * @memberof TracksApiGetTrendingTracksWithVersion
     */
    readonly version: string

    /**
     * The genre to filter to
     * @type {string}
     * @memberof TracksApiGetTrendingTracksWithVersion
     */
    readonly genre?: string

    /**
     * The time range to find trending tracks
     * @type {'week' | 'month' | 'year'}
     * @memberof TracksApiGetTrendingTracksWithVersion
     */
    readonly time?: 'week' | 'month' | 'year'

    /**
     * The number of items to fetch
     * @type {string}
     * @memberof TracksApiGetTrendingTracksWithVersion
     */
    readonly limit?: string

    /**
     * Used for pagination
     * @type {string}
     * @memberof TracksApiGetTrendingTracksWithVersion
     */
    readonly offset?: string

    /**
     * The currently logged in user ID
     * @type {string}
     * @memberof TracksApiGetTrendingTracksWithVersion
     */
    readonly userId?: string
}

/**
 * Request parameters for getUndergroundTrendingTracks operation in TracksApi.
 * @export
 * @interface TracksApiGetUndergroundTrendingTracksRequest
 */
export interface TracksApiGetUndergroundTrendingTracksRequest {
    /**
     * The number of items to fetch
     * @type {string}
     * @memberof TracksApiGetUndergroundTrendingTracks
     */
    readonly limit?: string

    /**
     * Used for pagination
     * @type {string}
     * @memberof TracksApiGetUndergroundTrendingTracks
     */
    readonly offset?: string

    /**
     * The currently logged in user ID
     * @type {string}
     * @memberof TracksApiGetUndergroundTrendingTracks
     */
    readonly userId?: string
}

/**
 * Request parameters for getUndergroundTrendingTracksWithVersion operation in TracksApi.
 * @export
 * @interface TracksApiGetUndergroundTrendingTracksWithVersionRequest
 */
export interface TracksApiGetUndergroundTrendingTracksWithVersionRequest {
    /**
     * The version of trending to use
     * @type {string}
     * @memberof TracksApiGetUndergroundTrendingTracksWithVersion
     */
    readonly version: string
}

/**
 * TracksApi - object-oriented interface
 * @export
 * @class TracksApi
 * @extends {BaseAPI}
 */
export class TracksApi extends BaseAPI {
    /**
     * Get track recommendations based on genre and trending
     * @param {TracksApiGetRecommendedTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getRecommendedTracks(requestParameters: TracksApiGetRecommendedTracksRequest = {}, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getRecommendedTracks(requestParameters.genre, requestParameters.limit, requestParameters.exclusionList, requestParameters.time, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get track recommendations based on genre and a specific trending version
     * @param {TracksApiGetRecommendedTracksWithVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getRecommendedTracksWithVersion(requestParameters: TracksApiGetRecommendedTracksWithVersionRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getRecommendedTracksWithVersion(requestParameters.version, requestParameters.genre, requestParameters.limit, requestParameters.exclusionList, requestParameters.time, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets tracks that have stems and are available to remix
     * @param {TracksApiGetRemixableTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getRemixableTracks(requestParameters: TracksApiGetRemixableTracksRequest = {}, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getRemixableTracks(requestParameters.userId, requestParameters.limit, requestParameters.withUsers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a track by its ID
     * @param {TracksApiGetTrackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrack(requestParameters: TracksApiGetTrackRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrack(requestParameters.trackId, requestParameters.handle, requestParameters.urlTitle, requestParameters.showUnlisted, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users that favorited a track
     * @param {TracksApiGetTrackFavoritersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrackFavoriters(requestParameters: TracksApiGetTrackFavoritersRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrackFavoriters(requestParameters.trackId, requestParameters.userId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the remixes of a track
     * @param {TracksApiGetTrackRemixesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrackRemixes(requestParameters: TracksApiGetTrackRemixesRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrackRemixes(requestParameters.trackId, requestParameters.userId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the tracks this track remixes
     * @param {TracksApiGetTrackRemixingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrackRemixing(requestParameters: TracksApiGetTrackRemixingRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrackRemixing(requestParameters.trackId, requestParameters.userId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets users that reposted a track
     * @param {TracksApiGetTrackRepostersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrackReposters(requestParameters: TracksApiGetTrackRepostersRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrackReposters(requestParameters.trackId, requestParameters.userId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the stems of the provided track
     * @param {TracksApiGetTrackStemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrackStems(requestParameters: TracksApiGetTrackStemsRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrackStems(requestParameters.trackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets full tracks by their route/permalinks
     * @param {TracksApiGetTracksByRouteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTracksByRoute(requestParameters: TracksApiGetTracksByRouteRequest = {}, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTracksByRoute(requestParameters.handle, requestParameters.slug, requestParameters.userId, requestParameters.route, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the track IDs of the top trending tracks on Audius
     * @param {TracksApiGetTrendingTrackIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrendingTrackIds(requestParameters: TracksApiGetTrendingTrackIdsRequest = {}, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrendingTrackIds(requestParameters.limit, requestParameters.genre, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the track IDs of the top trending tracks on Audius using the specified trending version
     * @param {TracksApiGetTrendingTrackIdsWithVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrendingTrackIdsWithVersion(requestParameters: TracksApiGetTrendingTrackIdsWithVersionRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrendingTrackIdsWithVersion(requestParameters.version, requestParameters.limit, requestParameters.genre, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the top trending tracks on Audius
     * @param {TracksApiGetTrendingTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrendingTracks(requestParameters: TracksApiGetTrendingTracksRequest = {}, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrendingTracks(requestParameters.genre, requestParameters.time, requestParameters.limit, requestParameters.offset, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the top trending tracks on Audius based on the trending version
     * @param {TracksApiGetTrendingTracksWithVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getTrendingTracksWithVersion(requestParameters: TracksApiGetTrendingTracksWithVersionRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getTrendingTracksWithVersion(requestParameters.version, requestParameters.genre, requestParameters.time, requestParameters.limit, requestParameters.offset, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the trending tracks for underground artists
     * @param {TracksApiGetUndergroundTrendingTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getUndergroundTrendingTracks(requestParameters: TracksApiGetUndergroundTrendingTracksRequest = {}, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getUndergroundTrendingTracks(requestParameters.limit, requestParameters.offset, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the trending tracks for underground artists using a specific trending calculator version
     * @param {TracksApiGetUndergroundTrendingTracksWithVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApi
     */
    public getUndergroundTrendingTracksWithVersion(requestParameters: TracksApiGetUndergroundTrendingTracksWithVersionRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getUndergroundTrendingTracksWithVersion(requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }
}
