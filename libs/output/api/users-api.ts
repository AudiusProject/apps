/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { FavoritesResponseFull } from '../model';
// @ts-ignore
import { FollowersResponse } from '../model';
// @ts-ignore
import { FollowingResponse } from '../model';
// @ts-ignore
import { FullReposts } from '../model';
// @ts-ignore
import { FullTracks } from '../model';
// @ts-ignore
import { FullUserResponse } from '../model';
// @ts-ignore
import { HistoryResponseFull } from '../model';
// @ts-ignore
import { RelatedArtistResponse } from '../model';
// @ts-ignore
import { TopGenreUsersResponse } from '../model';
// @ts-ignore
import { TopUsersResponse } from '../model';
// @ts-ignore
import { UsersByContentNode } from '../model';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
        * @param {UsersApiAllUsersThatFollowTheProvidedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUsersThatFollowTheProvidedUser: async ({  userId, userId2, limit, offset, }: UsersApiAllUsersThatFollowTheProvidedUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('allUsersThatFollowTheProvidedUser', 'userId', userId)
            // verify required parameter 'userId2' is not null or undefined
            assertParamExists('allUsersThatFollowTheProvidedUser', 'userId2', userId2)
            const localVarPath = `/users/{user_id}/followers`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId2 !== undefined) {
                localVarQueryParameter['user_id'] = userId2;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {UsersApiAllUsersThatTheProvidedUserFollowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUsersThatTheProvidedUserFollows: async ({  userId, userId2, limit, offset, }: UsersApiAllUsersThatTheProvidedUserFollowsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('allUsersThatTheProvidedUserFollows', 'userId', userId)
            // verify required parameter 'userId2' is not null or undefined
            assertParamExists('allUsersThatTheProvidedUserFollows', 'userId2', userId2)
            const localVarPath = `/users/{user_id}/following`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId2 !== undefined) {
                localVarQueryParameter['user_id'] = userId2;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {UsersApiGetFullUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullUser: async ({  userId, }: UsersApiGetFullUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFullUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {UsersApiGetFullUserHandleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullUserHandle: async ({  handle, }: UsersApiGetFullUserHandleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'handle' is not null or undefined
            assertParamExists('getFullUserHandle', 'handle', handle)
            const localVarPath = `/users/handle/{handle}`
                .replace(`{${"handle"}}`, encodeURIComponent(String(handle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {UsersApiGetTheTopUsersForAGivenGenreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheTopUsersForAGivenGenre: async ({  genre, limit, offset, }: UsersApiGetTheTopUsersForAGivenGenreRequest = {}, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            const localVarPath = `/users/genre/top`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (genre) {
                localVarQueryParameter['genre'] = genre;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheTopUsersHavingAtLeastOneTrackByFollowerCount: async ({  payload, limit, offset, }: UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('getTheTopUsersHavingAtLeastOneTrackByFollowerCount', 'payload', payload)
            const localVarPath = `/users/top`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - Leaving `/users/creator_node` above untouched for backwards-compatibility  Response = array of objects of schema { user_id, wallet, primary, secondary1, secondary2, primarySpId, secondary1SpID, secondary2SpID }
         * @summary New route to call get_users_cnode with replica_type param (only consumed by content node)
        * @param {UsersApiGetUsersByContentNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByContentNode: async ({  replicaType, }: UsersApiGetUsersByContentNodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'replicaType' is not null or undefined
            assertParamExists('getUsersByContentNode', 'replicaType', replicaType)
            const localVarPath = `/users/content_node/{replica_type}`
                .replace(`{${"replica_type"}}`, encodeURIComponent(String(replicaType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch favorited tracks for a user
        * @param {UsersApiGetUsersFavoriteTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFavoriteTracks: async ({  userId, userId2, limit, offset, }: UsersApiGetUsersFavoriteTracksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersFavoriteTracks', 'userId', userId)
            // verify required parameter 'userId2' is not null or undefined
            assertParamExists('getUsersFavoriteTracks', 'userId2', userId2)
            const localVarPath = `/users/{user_id}/favorites/tracks`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId2 !== undefined) {
                localVarQueryParameter['user_id'] = userId2;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {UsersApiGetUsersRepostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersReposts: async ({  handle, userId, limit, offset, }: UsersApiGetUsersRepostsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'handle' is not null or undefined
            assertParamExists('getUsersReposts', 'handle', handle)
            const localVarPath = `/users/handle/{handle}/reposts`
                .replace(`{${"handle"}}`, encodeURIComponent(String(handle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {UsersApiGetUsersReposts0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersReposts_1: async ({  userId, limit, offset, }: UsersApiGetUsersReposts0Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersReposts_1', 'userId', userId)
            const localVarPath = `/users/{user_id}/reposts`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch played tracks history for a user
        * @param {UsersApiGetUsersTrackHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTrackHistory: async ({  userId, userId2, limit, offset, }: UsersApiGetUsersTrackHistoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersTrackHistory', 'userId', userId)
            // verify required parameter 'userId2' is not null or undefined
            assertParamExists('getUsersTrackHistory', 'userId2', userId2)
            const localVarPath = `/users/{user_id}/history/tracks`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId2 !== undefined) {
                localVarQueryParameter['user_id'] = userId2;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a list of tracks for a user
        * @param {UsersApiGetUsersTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTracks: async ({  handle, userId, limit, offset, sort, }: UsersApiGetUsersTracksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'handle' is not null or undefined
            assertParamExists('getUsersTracks', 'handle', handle)
            const localVarPath = `/users/handle/{handle}/tracks`
                .replace(`{${"handle"}}`, encodeURIComponent(String(handle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a list of tracks for a user
        * @param {UsersApiGetUsersTracks0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTracks_2: async ({  userId, limit, offset, sort, }: UsersApiGetUsersTracks0Request, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUsersTracks_2', 'userId', userId)
            const localVarPath = `/users/{user_id}/tracks`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
        * @param {UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser: async ({  userId, userId2, limit, }: UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> =>  {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser', 'userId', userId)
            // verify required parameter 'userId2' is not null or undefined
            assertParamExists('getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser', 'userId2', userId2)
            const localVarPath = `/users/{user_id}/related`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId2 !== undefined) {
                localVarQueryParameter['user_id'] = userId2;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allUsersThatFollowTheProvidedUser(userId: string, userId2: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allUsersThatFollowTheProvidedUser({ userId, userId2, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allUsersThatTheProvidedUserFollows(userId: string, userId2: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allUsersThatTheProvidedUserFollows({ userId, userId2, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullUser({ userId, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} handle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullUserHandle(handle: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullUserHandle({ handle, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [genre] List of Genres
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTheTopUsersForAGivenGenre(genre?: Array<string>, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopGenreUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTheTopUsersForAGivenGenre({ genre, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TopUsersResponse} payload 
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTheTopUsersHavingAtLeastOneTrackByFollowerCount(payload: TopUsersResponse, limit?: string, offset?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTheTopUsersHavingAtLeastOneTrackByFollowerCount({ payload, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - Leaving `/users/creator_node` above untouched for backwards-compatibility  Response = array of objects of schema { user_id, wallet, primary, secondary1, secondary2, primarySpId, secondary1SpID, secondary2SpID }
         * @summary New route to call get_users_cnode with replica_type param (only consumed by content node)
         * @param {string} replicaType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByContentNode(replicaType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersByContentNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByContentNode({ replicaType, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch favorited tracks for a user
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersFavoriteTracks(userId: string, userId2: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoritesResponseFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersFavoriteTracks({ userId, userId2, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} handle 
         * @param {string} [userId] A User ID
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersReposts(handle: string, userId?: string, limit?: string, offset?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullReposts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersReposts({ handle, userId, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId A User ID
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersReposts_1(userId: string, limit?: string, offset?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullReposts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersReposts_1({ userId, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch played tracks history for a user
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTrackHistory(userId: string, userId2: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryResponseFull>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTrackHistory({ userId, userId2, limit, offset, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a list of tracks for a user
         * @param {string} handle 
         * @param {string} [userId] A User ID
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {string} [sort] Sort mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTracks(handle: string, userId?: string, limit?: string, offset?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTracks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTracks({ handle, userId, limit, offset, sort, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch a list of tracks for a user
         * @param {string} userId A User ID
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {string} [sort] Sort mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTracks_2(userId: string, limit?: string, offset?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FullTracks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTracks_2({ userId, limit, offset, sort, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser(userId: string, userId2: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedArtistResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser({ userId, userId2, limit, }, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUsersThatFollowTheProvidedUser(userId: string, userId2: string, limit?: number, offset?: number, options?: any): AxiosPromise<FollowersResponse> {
            return localVarFp.allUsersThatFollowTheProvidedUser(userId, userId2, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allUsersThatTheProvidedUserFollows(userId: string, userId2: string, limit?: number, offset?: number, options?: any): AxiosPromise<FollowingResponse> {
            return localVarFp.allUsersThatTheProvidedUserFollows(userId, userId2, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullUser(userId: string, options?: any): AxiosPromise<FullUserResponse> {
            return localVarFp.getFullUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} handle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullUserHandle(handle: string, options?: any): AxiosPromise<FullUserResponse> {
            return localVarFp.getFullUserHandle(handle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [genre] List of Genres
         * @param {number} [limit] Limit
         * @param {number} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheTopUsersForAGivenGenre(genre?: Array<string>, limit?: number, offset?: number, options?: any): AxiosPromise<TopGenreUsersResponse> {
            return localVarFp.getTheTopUsersForAGivenGenre(genre, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TopUsersResponse} payload 
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheTopUsersHavingAtLeastOneTrackByFollowerCount(payload: TopUsersResponse, limit?: string, offset?: string, options?: any): AxiosPromise<TopUsersResponse> {
            return localVarFp.getTheTopUsersHavingAtLeastOneTrackByFollowerCount(payload, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * - Leaving `/users/creator_node` above untouched for backwards-compatibility  Response = array of objects of schema { user_id, wallet, primary, secondary1, secondary2, primarySpId, secondary1SpID, secondary2SpID }
         * @summary New route to call get_users_cnode with replica_type param (only consumed by content node)
         * @param {string} replicaType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByContentNode(replicaType: string, options?: any): AxiosPromise<UsersByContentNode> {
            return localVarFp.getUsersByContentNode(replicaType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch favorited tracks for a user
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFavoriteTracks(userId: string, userId2: string, limit?: number, offset?: number, options?: any): AxiosPromise<FavoritesResponseFull> {
            return localVarFp.getUsersFavoriteTracks(userId, userId2, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} handle 
         * @param {string} [userId] A User ID
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersReposts(handle: string, userId?: string, limit?: string, offset?: string, options?: any): AxiosPromise<FullReposts> {
            return localVarFp.getUsersReposts(handle, userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId A User ID
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersReposts_1(userId: string, limit?: string, offset?: string, options?: any): AxiosPromise<FullReposts> {
            return localVarFp.getUsersReposts_1(userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch played tracks history for a user
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTrackHistory(userId: string, userId2: string, limit?: number, offset?: number, options?: any): AxiosPromise<HistoryResponseFull> {
            return localVarFp.getUsersTrackHistory(userId, userId2, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a list of tracks for a user
         * @param {string} handle 
         * @param {string} [userId] A User ID
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {string} [sort] Sort mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTracks(handle: string, userId?: string, limit?: string, offset?: string, sort?: string, options?: any): AxiosPromise<FullTracks> {
            return localVarFp.getUsersTracks(handle, userId, limit, offset, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a list of tracks for a user
         * @param {string} userId A User ID
         * @param {string} [limit] Limit
         * @param {string} [offset] Offset
         * @param {string} [sort] Sort mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTracks_2(userId: string, limit?: string, offset?: string, sort?: string, options?: any): AxiosPromise<FullTracks> {
            return localVarFp.getUsersTracks_2(userId, limit, offset, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} userId2 A User ID
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser(userId: string, userId2: string, limit?: number, options?: any): AxiosPromise<RelatedArtistResponse> {
            return localVarFp.getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser(userId, userId2, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for allUsersThatFollowTheProvidedUser operation in UsersApi.
 * @export
 * @interface UsersApiAllUsersThatFollowTheProvidedUserRequest
 */
export interface UsersApiAllUsersThatFollowTheProvidedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiAllUsersThatFollowTheProvidedUser
     */
    readonly userId: string

    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiAllUsersThatFollowTheProvidedUser
     */
    readonly userId2: string

    /**
     * Limit
     * @type {number}
     * @memberof UsersApiAllUsersThatFollowTheProvidedUser
     */
    readonly limit?: number

    /**
     * Offset
     * @type {number}
     * @memberof UsersApiAllUsersThatFollowTheProvidedUser
     */
    readonly offset?: number
}

/**
 * Request parameters for allUsersThatTheProvidedUserFollows operation in UsersApi.
 * @export
 * @interface UsersApiAllUsersThatTheProvidedUserFollowsRequest
 */
export interface UsersApiAllUsersThatTheProvidedUserFollowsRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiAllUsersThatTheProvidedUserFollows
     */
    readonly userId: string

    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiAllUsersThatTheProvidedUserFollows
     */
    readonly userId2: string

    /**
     * Limit
     * @type {number}
     * @memberof UsersApiAllUsersThatTheProvidedUserFollows
     */
    readonly limit?: number

    /**
     * Offset
     * @type {number}
     * @memberof UsersApiAllUsersThatTheProvidedUserFollows
     */
    readonly offset?: number
}

/**
 * Request parameters for getFullUser operation in UsersApi.
 * @export
 * @interface UsersApiGetFullUserRequest
 */
export interface UsersApiGetFullUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetFullUser
     */
    readonly userId: string
}

/**
 * Request parameters for getFullUserHandle operation in UsersApi.
 * @export
 * @interface UsersApiGetFullUserHandleRequest
 */
export interface UsersApiGetFullUserHandleRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetFullUserHandle
     */
    readonly handle: string
}

/**
 * Request parameters for getTheTopUsersForAGivenGenre operation in UsersApi.
 * @export
 * @interface UsersApiGetTheTopUsersForAGivenGenreRequest
 */
export interface UsersApiGetTheTopUsersForAGivenGenreRequest {
    /**
     * List of Genres
     * @type {Array<string>}
     * @memberof UsersApiGetTheTopUsersForAGivenGenre
     */
    readonly genre?: Array<string>

    /**
     * Limit
     * @type {number}
     * @memberof UsersApiGetTheTopUsersForAGivenGenre
     */
    readonly limit?: number

    /**
     * Offset
     * @type {number}
     * @memberof UsersApiGetTheTopUsersForAGivenGenre
     */
    readonly offset?: number
}

/**
 * Request parameters for getTheTopUsersHavingAtLeastOneTrackByFollowerCount operation in UsersApi.
 * @export
 * @interface UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCountRequest
 */
export interface UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCountRequest {
    /**
     * 
     * @type {TopUsersResponse}
     * @memberof UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCount
     */
    readonly payload: TopUsersResponse

    /**
     * Limit
     * @type {string}
     * @memberof UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCount
     */
    readonly limit?: string

    /**
     * Offset
     * @type {string}
     * @memberof UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCount
     */
    readonly offset?: string
}

/**
 * Request parameters for getUsersByContentNode operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersByContentNodeRequest
 */
export interface UsersApiGetUsersByContentNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsersByContentNode
     */
    readonly replicaType: string
}

/**
 * Request parameters for getUsersFavoriteTracks operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersFavoriteTracksRequest
 */
export interface UsersApiGetUsersFavoriteTracksRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsersFavoriteTracks
     */
    readonly userId: string

    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiGetUsersFavoriteTracks
     */
    readonly userId2: string

    /**
     * 
     * @type {number}
     * @memberof UsersApiGetUsersFavoriteTracks
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiGetUsersFavoriteTracks
     */
    readonly offset?: number
}

/**
 * Request parameters for getUsersReposts operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersRepostsRequest
 */
export interface UsersApiGetUsersRepostsRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsersReposts
     */
    readonly handle: string

    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiGetUsersReposts
     */
    readonly userId?: string

    /**
     * Limit
     * @type {string}
     * @memberof UsersApiGetUsersReposts
     */
    readonly limit?: string

    /**
     * Offset
     * @type {string}
     * @memberof UsersApiGetUsersReposts
     */
    readonly offset?: string
}

/**
 * Request parameters for getUsersReposts_1 operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersReposts0Request
 */
export interface UsersApiGetUsersReposts0Request {
    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiGetUsersReposts0
     */
    readonly userId: string

    /**
     * Limit
     * @type {string}
     * @memberof UsersApiGetUsersReposts0
     */
    readonly limit?: string

    /**
     * Offset
     * @type {string}
     * @memberof UsersApiGetUsersReposts0
     */
    readonly offset?: string
}

/**
 * Request parameters for getUsersTrackHistory operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersTrackHistoryRequest
 */
export interface UsersApiGetUsersTrackHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsersTrackHistory
     */
    readonly userId: string

    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiGetUsersTrackHistory
     */
    readonly userId2: string

    /**
     * 
     * @type {number}
     * @memberof UsersApiGetUsersTrackHistory
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiGetUsersTrackHistory
     */
    readonly offset?: number
}

/**
 * Request parameters for getUsersTracks operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersTracksRequest
 */
export interface UsersApiGetUsersTracksRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetUsersTracks
     */
    readonly handle: string

    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiGetUsersTracks
     */
    readonly userId?: string

    /**
     * Limit
     * @type {string}
     * @memberof UsersApiGetUsersTracks
     */
    readonly limit?: string

    /**
     * Offset
     * @type {string}
     * @memberof UsersApiGetUsersTracks
     */
    readonly offset?: string

    /**
     * Sort mode
     * @type {string}
     * @memberof UsersApiGetUsersTracks
     */
    readonly sort?: string
}

/**
 * Request parameters for getUsersTracks_2 operation in UsersApi.
 * @export
 * @interface UsersApiGetUsersTracks0Request
 */
export interface UsersApiGetUsersTracks0Request {
    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiGetUsersTracks0
     */
    readonly userId: string

    /**
     * Limit
     * @type {string}
     * @memberof UsersApiGetUsersTracks0
     */
    readonly limit?: string

    /**
     * Offset
     * @type {string}
     * @memberof UsersApiGetUsersTracks0
     */
    readonly offset?: string

    /**
     * Sort mode
     * @type {string}
     * @memberof UsersApiGetUsersTracks0
     */
    readonly sort?: string
}

/**
 * Request parameters for getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser operation in UsersApi.
 * @export
 * @interface UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUserRequest
 */
export interface UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser
     */
    readonly userId: string

    /**
     * A User ID
     * @type {string}
     * @memberof UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser
     */
    readonly userId2: string

    /**
     * Limit
     * @type {number}
     * @memberof UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser
     */
    readonly limit?: number
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {UsersApiAllUsersThatFollowTheProvidedUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public allUsersThatFollowTheProvidedUser(requestParameters: UsersApiAllUsersThatFollowTheProvidedUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).allUsersThatFollowTheProvidedUser(requestParameters.userId, requestParameters.userId2, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiAllUsersThatTheProvidedUserFollowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public allUsersThatTheProvidedUserFollows(requestParameters: UsersApiAllUsersThatTheProvidedUserFollowsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).allUsersThatTheProvidedUserFollows(requestParameters.userId, requestParameters.userId2, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiGetFullUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFullUser(requestParameters: UsersApiGetFullUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFullUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiGetFullUserHandleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getFullUserHandle(requestParameters: UsersApiGetFullUserHandleRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFullUserHandle(requestParameters.handle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiGetTheTopUsersForAGivenGenreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getTheTopUsersForAGivenGenre(requestParameters: UsersApiGetTheTopUsersForAGivenGenreRequest = {}, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getTheTopUsersForAGivenGenre(requestParameters.genre, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getTheTopUsersHavingAtLeastOneTrackByFollowerCount(requestParameters: UsersApiGetTheTopUsersHavingAtLeastOneTrackByFollowerCountRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getTheTopUsersHavingAtLeastOneTrackByFollowerCount(requestParameters.payload, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - Leaving `/users/creator_node` above untouched for backwards-compatibility  Response = array of objects of schema { user_id, wallet, primary, secondary1, secondary2, primarySpId, secondary1SpID, secondary2SpID }
     * @summary New route to call get_users_cnode with replica_type param (only consumed by content node)
     * @param {UsersApiGetUsersByContentNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersByContentNode(requestParameters: UsersApiGetUsersByContentNodeRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersByContentNode(requestParameters.replicaType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch favorited tracks for a user
     * @param {UsersApiGetUsersFavoriteTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersFavoriteTracks(requestParameters: UsersApiGetUsersFavoriteTracksRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersFavoriteTracks(requestParameters.userId, requestParameters.userId2, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiGetUsersRepostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersReposts(requestParameters: UsersApiGetUsersRepostsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersReposts(requestParameters.handle, requestParameters.userId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiGetUsersReposts0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersReposts_1(requestParameters: UsersApiGetUsersReposts0Request, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersReposts_1(requestParameters.userId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch played tracks history for a user
     * @param {UsersApiGetUsersTrackHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTrackHistory(requestParameters: UsersApiGetUsersTrackHistoryRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTrackHistory(requestParameters.userId, requestParameters.userId2, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a list of tracks for a user
     * @param {UsersApiGetUsersTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTracks(requestParameters: UsersApiGetUsersTracksRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTracks(requestParameters.handle, requestParameters.userId, requestParameters.limit, requestParameters.offset, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a list of tracks for a user
     * @param {UsersApiGetUsersTracks0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTracks_2(requestParameters: UsersApiGetUsersTracks0Request, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTracks_2(requestParameters.userId, requestParameters.limit, requestParameters.offset, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser(requestParameters: UsersApiGetsAListOfUsersThatMightBeOfInterestToFollowersOfThisUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getsAListOfUsersThatMightBeOfInterestToFollowersOfThisUser(requestParameters.userId, requestParameters.userId2, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}
