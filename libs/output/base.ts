/* tslint:disable */
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from "./configuration";
import DiscoveryProviderSelection from './discovery-provider-selection';
// Some imports not used depending on template conditions
// @ts-ignore
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';

export const BASE_PATH = "http://localhost/v1/full".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: AxiosRequestConfig;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    /**
     * The currently selected Discovery Provider to use for queries
     */
    protected discoveryProviderEndpoint: string;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
        this.serviceSelection = new DiscoveryProviderSelection({})
    }


  /**
   * Gets the healthy discovery provider endpoint used in creating the axios request later.
   * If the number of retries is over the max count for retires, clear the cache and reselect
   * another healthy discovery provider. Else, return the current discovery provider endpoint
   * @param {number} attemptedRetries the number of attempted requests made to the current disc prov endpoint
   */
  async getHealthyDiscoveryProviderEndpoint (attemptedRetries) {
    let endpoint = this.discoveryProviderEndpoint
    if (attemptedRetries > this.selectionRequestRetries) {
      // Add to unhealthy list if current disc prov endpoint has reached max retry count
      console.info(`Attempted max retries with endpoint ${endpoint}`)
      this.serviceSelector.addUnhealthy(endpoint)

      // Clear the cached endpoint and select new endpoint from backups
      this.serviceSelector.clearCached()
      endpoint = await this.serviceSelector.select()
    }

    // If there are no more available backups, throw error
    if (!endpoint) {
      throw new Error('All Discovery Providers are unhealthy and unavailable.')
    }

    return endpoint
  }

  /**
   * Performs a single request, defined in the request, via axios, calling any
   * monitoring callbacks as needed.
   * @param {string} discoveryProviderEndpoint
   * @returns
   * @memberof DiscoveryProvider
   */
   async _performRequestWithMonitoring (requestObj, discoveryProviderEndpoint) {
    const axiosRequest = this._createDiscProvRequest(requestObj, discoveryProviderEndpoint)
    let response
    let parsedResponse

    const url = new URL(axiosRequest.url)
    const start = Date.now()
    try {
      response = await axios(axiosRequest)
      const duration = Date.now() - start
      parsedResponse = Utils.parseDataFromResponse(response)

      // Fire monitoring callbacks for request success case
      if (this.monitoringCallbacks.request) {
        try {
          this.monitoringCallbacks.request({
            endpoint: url.origin,
            pathname: url.pathname,
            queryString: url.search,
            signer: response.data.signer,
            signature: response.data.signature,
            requestMethod: axiosRequest.method,
            status: response.status,
            responseTimeMillis: duration
          })
        } catch (e) {
          // Swallow errors -- this method should not throw generally
          console.error(e)
        }
      }
    } catch (e) {
      const resp = e.response || {}
      const duration = Date.now() - start
      const errMsg = e.response && e.response.data ? e.response.data : e

      // Fire monitoring callbaks for request failure case
      if (this.monitoringCallbacks.request) {
        try {
          this.monitoringCallbacks.request({
            endpoint: url.origin,
            pathname: url.pathname,
            queryString: url.search,
            requestMethod: axiosRequest.method,
            status: resp.status,
            responseTimeMillis: duration
          })
        } catch (e) {
          // Swallow errors -- this method should not throw generally
          console.error(e)
        }
      }
      throw errMsg
    }
    return parsedResponse
  }

  /**
   * Makes a request to a discovery node, reselecting if necessary
   * @param {boolean?} retry whether to retry on failure
   * @param {number?} attemptedRetries number of attempted retries (stops retrying at max)
   */
  async _makeRequest (requestObj, retry = true, attemptedRetries = 0) {
    try {
      const newDiscProvEndpoint = await this.getHealthyDiscoveryProviderEndpoint(attemptedRetries)

      // If new DP endpoint is selected, update disc prov endpoint and reset attemptedRetries count
      if (this.discoveryProviderEndpoint !== newDiscProvEndpoint) {
        let updateDiscProvEndpointMsg = `Current Discovery Provider endpoint ${this.discoveryProviderEndpoint} is unhealthy. `
        updateDiscProvEndpointMsg += `Switching over to the new Discovery Provider endpoint ${newDiscProvEndpoint}!`
        console.info(updateDiscProvEndpointMsg)
        this.discoveryProviderEndpoint = newDiscProvEndpoint
        attemptedRetries = 0
      }
    } catch (e) {
      console.error(e)
      return
    }
    let parsedResponse
    try {
      parsedResponse = await this._performRequestWithMonitoring(requestObj, this.discoveryProviderEndpoint)
    } catch (e) {
      const fullErrString = `Failed to make Discovery Provider request at attempt #${attemptedRetries}, error ${JSON.stringify(e.message)}, request: ${JSON.stringify(requestObj)}`
      console.error(fullErrString)
      if (retry) {
        return this._makeRequest(requestObj, retry, attemptedRetries + 1)
      }
      return null
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}
