/* tslint:disable */
// @ts-nocheck
/* eslint-disable */
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuthorizedApps,
  ConnectedWalletsResponse,
  DeveloperApps,
  FavoritesResponse,
  FollowersResponse,
  FollowingResponse,
  GetSupporters,
  GetSupporting,
  RelatedArtistResponse,
  Reposts,
  SubscribersResponse,
  TagsResponse,
  TracksResponse,
  UserAssociatedWalletResponse,
  UserResponse,
  UserSearch,
  VerifyToken,
} from '../models';
import {
    AuthorizedAppsFromJSON,
    AuthorizedAppsToJSON,
    ConnectedWalletsResponseFromJSON,
    ConnectedWalletsResponseToJSON,
    DeveloperAppsFromJSON,
    DeveloperAppsToJSON,
    FavoritesResponseFromJSON,
    FavoritesResponseToJSON,
    FollowersResponseFromJSON,
    FollowersResponseToJSON,
    FollowingResponseFromJSON,
    FollowingResponseToJSON,
    GetSupportersFromJSON,
    GetSupportersToJSON,
    GetSupportingFromJSON,
    GetSupportingToJSON,
    RelatedArtistResponseFromJSON,
    RelatedArtistResponseToJSON,
    RepostsFromJSON,
    RepostsToJSON,
    SubscribersResponseFromJSON,
    SubscribersResponseToJSON,
    TagsResponseFromJSON,
    TagsResponseToJSON,
    TracksResponseFromJSON,
    TracksResponseToJSON,
    UserAssociatedWalletResponseFromJSON,
    UserAssociatedWalletResponseToJSON,
    UserResponseFromJSON,
    UserResponseToJSON,
    UserSearchFromJSON,
    UserSearchToJSON,
    VerifyTokenFromJSON,
    VerifyTokenToJSON,
} from '../models';

export interface GetAIAttributedTracksByUserHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetAIAttributedTracksByUserHandleSortEnum;
    query?: string;
    sortMethod?: GetAIAttributedTracksByUserHandleSortMethodEnum;
    sortDirection?: GetAIAttributedTracksByUserHandleSortDirectionEnum;
    filterTracks?: GetAIAttributedTracksByUserHandleFilterTracksEnum;
}

export interface GetAuthorizedAppsRequest {
    id: string;
}

export interface GetConnectedWalletsRequest {
    id: string;
}

export interface GetDeveloperAppsRequest {
    id: string;
}

export interface GetFavoritesRequest {
    id: string;
}

export interface GetFollowersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetFollowingRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRelatedUsersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRepostsRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSubscribersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSupportersRequest {
    id: string;
    offset?: number;
    limit?: number;
}

export interface GetSupportingsRequest {
    id: string;
    offset?: number;
    limit?: number;
}

export interface GetTopTrackTagsRequest {
    id: string;
    limit?: number;
    userId?: string;
}

export interface GetTracksByUserRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetTracksByUserSortEnum;
    query?: string;
    sortMethod?: GetTracksByUserSortMethodEnum;
    sortDirection?: GetTracksByUserSortDirectionEnum;
    filterTracks?: GetTracksByUserFilterTracksEnum;
}

export interface GetUserRequest {
    id: string;
}

export interface GetUserByHandleRequest {
    handle: string;
    userId?: string;
}

export interface GetUserIDFromWalletRequest {
    associatedWallet: string;
}

export interface SearchUsersRequest {
    query: string;
}

export interface VerifyIDTokenRequest {
    token: string;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandleRaw(requestParameters: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TracksResponse>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = requestParameters.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
    }

    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandle(requestParameters: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TracksResponse> {
        const response = await this.getAIAttributedTracksByUserHandleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get the apps that user has authorized to write to their account
     */
    async getAuthorizedAppsRaw(requestParameters: GetAuthorizedAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorizedApps>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getAuthorizedApps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/authorized_apps`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizedAppsFromJSON(jsonValue));
    }

    /**
     * Get the apps that user has authorized to write to their account
     */
    async getAuthorizedApps(requestParameters: GetAuthorizedAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorizedApps> {
        const response = await this.getAuthorizedAppsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get the User\'s ERC and SPL connected wallets
     */
    async getConnectedWalletsRaw(requestParameters: GetConnectedWalletsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConnectedWalletsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getConnectedWallets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/connected_wallets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectedWalletsResponseFromJSON(jsonValue));
    }

    /**
     * Get the User\'s ERC and SPL connected wallets
     */
    async getConnectedWallets(requestParameters: GetConnectedWalletsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConnectedWalletsResponse> {
        const response = await this.getConnectedWalletsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the developer apps that the user owns
     */
    async getDeveloperAppsRaw(requestParameters: GetDeveloperAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeveloperApps>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getDeveloperApps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/developer_apps`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeveloperAppsFromJSON(jsonValue));
    }

    /**
     * Gets the developer apps that the user owns
     */
    async getDeveloperApps(requestParameters: GetDeveloperAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeveloperApps> {
        const response = await this.getDeveloperAppsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a user\'s favorite tracks
     */
    async getFavoritesRaw(requestParameters: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoritesResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFavorites.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/favorites`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FavoritesResponseFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s favorite tracks
     */
    async getFavorites(requestParameters: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoritesResponse> {
        const response = await this.getFavoritesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that follow the provided user
     */
    async getFollowersRaw(requestParameters: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFollowers.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowersResponseFromJSON(jsonValue));
    }

    /**
     * All users that follow the provided user
     */
    async getFollowers(requestParameters: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowersResponse> {
        const response = await this.getFollowersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that the provided user follows
     */
    async getFollowingRaw(requestParameters: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFollowing.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowingResponseFromJSON(jsonValue));
    }

    /**
     * All users that the provided user follows
     */
    async getFollowing(requestParameters: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowingResponse> {
        const response = await this.getFollowingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsersRaw(requestParameters: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RelatedArtistResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getRelatedUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RelatedArtistResponseFromJSON(jsonValue));
    }

    /**
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsers(requestParameters: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RelatedArtistResponse> {
        const response = await this.getRelatedUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the given user\'s reposts
     */
    async getRepostsRaw(requestParameters: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Reposts>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getReposts.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepostsFromJSON(jsonValue));
    }

    /**
     * Gets the given user\'s reposts
     */
    async getReposts(requestParameters: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Reposts> {
        const response = await this.getRepostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that subscribe to the provided user
     */
    async getSubscribersRaw(requestParameters: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubscribersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSubscribers.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscribersResponseFromJSON(jsonValue));
    }

    /**
     * All users that subscribe to the provided user
     */
    async getSubscribers(requestParameters: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubscribersResponse> {
        const response = await this.getSubscribersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the supporters of the given user
     */
    async getSupportersRaw(requestParameters: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSupporters>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupporters.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSupportersFromJSON(jsonValue));
    }

    /**
     * Gets the supporters of the given user
     */
    async getSupporters(requestParameters: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSupporters> {
        const response = await this.getSupportersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the users that the given user supports
     */
    async getSupportingsRaw(requestParameters: GetSupportingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSupporting>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupportings.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSupportingFromJSON(jsonValue));
    }

    /**
     * Gets the users that the given user supports
     */
    async getSupportings(requestParameters: GetSupportingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSupporting> {
        const response = await this.getSupportingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */
    async getTopTrackTagsRaw(requestParameters: GetTopTrackTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTopTrackTags.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/tags`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagsResponseFromJSON(jsonValue));
    }

    /**
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */
    async getTopTrackTags(requestParameters: GetTopTrackTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagsResponse> {
        const response = await this.getTopTrackTagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUserRaw(requestParameters: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TracksResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTracksByUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = requestParameters.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
    }

    /**
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUser(requestParameters: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TracksResponse> {
        const response = await this.getTracksByUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a single user by their user ID
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their user ID
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a single user by their handle
     */
    async getUserByHandleRaw(requestParameters: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getUserByHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their handle
     */
    async getUserByHandle(requestParameters: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.getUserByHandleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a User ID from an associated wallet address
     */
    async getUserIDFromWalletRaw(requestParameters: GetUserIDFromWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserAssociatedWalletResponse>> {
        if (requestParameters.associatedWallet === null || requestParameters.associatedWallet === undefined) {
            throw new runtime.RequiredError('associatedWallet','Required parameter requestParameters.associatedWallet was null or undefined when calling getUserIDFromWallet.');
        }

        const queryParameters: any = {};

        if (requestParameters.associatedWallet !== undefined) {
            queryParameters['associated_wallet'] = requestParameters.associatedWallet;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/id`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserAssociatedWalletResponseFromJSON(jsonValue));
    }

    /**
     * Gets a User ID from an associated wallet address
     */
    async getUserIDFromWallet(requestParameters: GetUserIDFromWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserAssociatedWalletResponse> {
        const response = await this.getUserIDFromWalletRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Search for users that match the given query
     */
    async searchUsersRaw(requestParameters: SearchUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSearch>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling searchUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSearchFromJSON(jsonValue));
    }

    /**
     * Search for users that match the given query
     */
    async searchUsers(requestParameters: SearchUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSearch> {
        const response = await this.searchUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */
    async verifyIDTokenRaw(requestParameters: VerifyIDTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VerifyToken>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling verifyIDToken.');
        }

        const queryParameters: any = {};

        if (requestParameters.token !== undefined) {
            queryParameters['token'] = requestParameters.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/verify_token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VerifyTokenFromJSON(jsonValue));
    }

    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */
    async verifyIDToken(requestParameters: VerifyIDTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VerifyToken> {
        const response = await this.verifyIDTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetAIAttributedTracksByUserHandleSortEnum = typeof GetAIAttributedTracksByUserHandleSortEnum[keyof typeof GetAIAttributedTracksByUserHandleSortEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Length: 'length',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetAIAttributedTracksByUserHandleSortMethodEnum = typeof GetAIAttributedTracksByUserHandleSortMethodEnum[keyof typeof GetAIAttributedTracksByUserHandleSortMethodEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAIAttributedTracksByUserHandleSortDirectionEnum = typeof GetAIAttributedTracksByUserHandleSortDirectionEnum[keyof typeof GetAIAttributedTracksByUserHandleSortDirectionEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetAIAttributedTracksByUserHandleFilterTracksEnum = typeof GetAIAttributedTracksByUserHandleFilterTracksEnum[keyof typeof GetAIAttributedTracksByUserHandleFilterTracksEnum];
/**
 * @export
 */
export const GetTracksByUserSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetTracksByUserSortEnum = typeof GetTracksByUserSortEnum[keyof typeof GetTracksByUserSortEnum];
/**
 * @export
 */
export const GetTracksByUserSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Length: 'length',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetTracksByUserSortMethodEnum = typeof GetTracksByUserSortMethodEnum[keyof typeof GetTracksByUserSortMethodEnum];
/**
 * @export
 */
export const GetTracksByUserSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetTracksByUserSortDirectionEnum = typeof GetTracksByUserSortDirectionEnum[keyof typeof GetTracksByUserSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetTracksByUserFilterTracksEnum = typeof GetTracksByUserFilterTracksEnum[keyof typeof GetTracksByUserFilterTracksEnum];
