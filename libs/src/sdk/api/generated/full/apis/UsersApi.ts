/* tslint:disable */
// @ts-nocheck
/* eslint-disable */
/**
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  FavoritesResponseFull,
  FollowingResponseFull,
  FullBulkSubscribersResponse,
  FullFollowersResponse,
  FullGetSupporter,
  FullGetSupporters,
  FullGetSupporting,
  FullReposts,
  FullSubscribersResponse,
  FullTracks,
  FullUserResponse,
  HistoryResponseFull,
  RelatedArtistResponseFull,
  TopGenreUsersResponseFull,
  TopUsersResponseFull,
  UsersByContentNode,
} from '../models';
import {
    FavoritesResponseFullFromJSON,
    FavoritesResponseFullToJSON,
    FollowingResponseFullFromJSON,
    FollowingResponseFullToJSON,
    FullBulkSubscribersResponseFromJSON,
    FullBulkSubscribersResponseToJSON,
    FullFollowersResponseFromJSON,
    FullFollowersResponseToJSON,
    FullGetSupporterFromJSON,
    FullGetSupporterToJSON,
    FullGetSupportersFromJSON,
    FullGetSupportersToJSON,
    FullGetSupportingFromJSON,
    FullGetSupportingToJSON,
    FullRepostsFromJSON,
    FullRepostsToJSON,
    FullSubscribersResponseFromJSON,
    FullSubscribersResponseToJSON,
    FullTracksFromJSON,
    FullTracksToJSON,
    FullUserResponseFromJSON,
    FullUserResponseToJSON,
    HistoryResponseFullFromJSON,
    HistoryResponseFullToJSON,
    RelatedArtistResponseFullFromJSON,
    RelatedArtistResponseFullToJSON,
    TopGenreUsersResponseFullFromJSON,
    TopGenreUsersResponseFullToJSON,
    TopUsersResponseFullFromJSON,
    TopUsersResponseFullToJSON,
    UsersByContentNodeFromJSON,
    UsersByContentNodeToJSON,
} from '../models';

export interface BulkGetSubscribersRequest {
    ids: Array<string>;
}

export interface BulkGetSubscribersViaJSONRequestRequest {
    ids: Array<string>;
}

export interface GetAIAttributedTracksByUserHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetAIAttributedTracksByUserHandleSortEnum;
    query?: string;
    sortMethod?: GetAIAttributedTracksByUserHandleSortMethodEnum;
    sortDirection?: GetAIAttributedTracksByUserHandleSortDirectionEnum;
    filterTracks?: GetAIAttributedTracksByUserHandleFilterTracksEnum;
}

export interface GetFavoritesRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    query?: string;
    sortMethod?: GetFavoritesSortMethodEnum;
    sortDirection?: GetFavoritesSortDirectionEnum;
}

export interface GetFollowersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetFollowingRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRelatedUsersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRepostsRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRepostsByHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSubscribersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSupporterRequest {
    id: string;
    supporterUserId: string;
    userId?: string;
}

export interface GetSupportersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSupportingRequest {
    id: string;
    supportedUserId: string;
    userId?: string;
}

export interface GetSupportingsRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetTopUsersRequest {
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetTopUsersInGenreRequest {
    offset?: number;
    limit?: number;
    genre?: Array<string>;
}

export interface GetTracksByUserRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetTracksByUserSortEnum;
    query?: string;
    sortMethod?: GetTracksByUserSortMethodEnum;
    sortDirection?: GetTracksByUserSortDirectionEnum;
    filterTracks?: GetTracksByUserFilterTracksEnum;
}

export interface GetTracksByUserHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetTracksByUserHandleSortEnum;
    query?: string;
    sortMethod?: GetTracksByUserHandleSortMethodEnum;
    sortDirection?: GetTracksByUserHandleSortDirectionEnum;
    filterTracks?: GetTracksByUserHandleFilterTracksEnum;
}

export interface GetUserRequest {
    id: string;
    userId?: string;
}

export interface GetUserByHandleRequest {
    handle: string;
    userId?: string;
}

export interface GetUserLibraryTracksRequest {
    id: string;
    encodedDataMessage: string;
    encodedDataSignature: string;
    offset?: number;
    limit?: number;
    userId?: string;
    query?: string;
    sortMethod?: GetUserLibraryTracksSortMethodEnum;
    sortDirection?: GetUserLibraryTracksSortDirectionEnum;
    type?: GetUserLibraryTracksTypeEnum;
}

export interface GetUserReplicaSetRequest {
    id: string;
    userId?: string;
}

export interface GetUsersTrackHistoryRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    query?: string;
    sortMethod?: GetUsersTrackHistorySortMethodEnum;
    sortDirection?: GetUsersTrackHistorySortDirectionEnum;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /** @hidden
     * All users that subscribe to the provided users
     */
    async bulkGetSubscribersRaw(requestParameters: BulkGetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullBulkSubscribersResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter requestParameters.ids was null or undefined when calling bulkGetSubscribers.');
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/subscribers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullBulkSubscribersResponseFromJSON(jsonValue));
    }

    /**
     * All users that subscribe to the provided users
     */
    async bulkGetSubscribers(requestParameters: BulkGetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullBulkSubscribersResponse> {
        const response = await this.bulkGetSubscribersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get all users that subscribe to the users listed in the JSON request
     */
    async bulkGetSubscribersViaJSONRequestRaw(requestParameters: BulkGetSubscribersViaJSONRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullBulkSubscribersResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter requestParameters.ids was null or undefined when calling bulkGetSubscribersViaJSONRequest.');
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/subscribers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullBulkSubscribersResponseFromJSON(jsonValue));
    }

    /**
     * Get all users that subscribe to the users listed in the JSON request
     */
    async bulkGetSubscribersViaJSONRequest(requestParameters: BulkGetSubscribersViaJSONRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullBulkSubscribersResponse> {
        const response = await this.bulkGetSubscribersViaJSONRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandleRaw(requestParameters: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullTracks>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = requestParameters.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
    }

    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandle(requestParameters: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullTracks> {
        const response = await this.getAIAttributedTracksByUserHandleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a user\'s favorite tracks
     */
    async getFavoritesRaw(requestParameters: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoritesResponseFull>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFavorites.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/favorites/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FavoritesResponseFullFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s favorite tracks
     */
    async getFavorites(requestParameters: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoritesResponseFull> {
        const response = await this.getFavoritesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that follow the provided user
     */
    async getFollowersRaw(requestParameters: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullFollowersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFollowers.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullFollowersResponseFromJSON(jsonValue));
    }

    /**
     * All users that follow the provided user
     */
    async getFollowers(requestParameters: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullFollowersResponse> {
        const response = await this.getFollowersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that the provided user follows
     */
    async getFollowingRaw(requestParameters: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowingResponseFull>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFollowing.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowingResponseFullFromJSON(jsonValue));
    }

    /**
     * All users that the provided user follows
     */
    async getFollowing(requestParameters: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowingResponseFull> {
        const response = await this.getFollowingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsersRaw(requestParameters: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RelatedArtistResponseFull>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getRelatedUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RelatedArtistResponseFullFromJSON(jsonValue));
    }

    /**
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsers(requestParameters: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RelatedArtistResponseFull> {
        const response = await this.getRelatedUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the given user\'s reposts
     */
    async getRepostsRaw(requestParameters: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullReposts>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getReposts.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullRepostsFromJSON(jsonValue));
    }

    /**
     * Gets the given user\'s reposts
     */
    async getReposts(requestParameters: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullReposts> {
        const response = await this.getRepostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the user\'s reposts by the user handle
     */
    async getRepostsByHandleRaw(requestParameters: GetRepostsByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullReposts>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getRepostsByHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}/reposts`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullRepostsFromJSON(jsonValue));
    }

    /**
     * Gets the user\'s reposts by the user handle
     */
    async getRepostsByHandle(requestParameters: GetRepostsByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullReposts> {
        const response = await this.getRepostsByHandleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * All users that subscribe to the provided user
     */
    async getSubscribersRaw(requestParameters: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullSubscribersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSubscribers.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullSubscribersResponseFromJSON(jsonValue));
    }

    /**
     * All users that subscribe to the provided user
     */
    async getSubscribers(requestParameters: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullSubscribersResponse> {
        const response = await this.getSubscribersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the specified supporter of the given user
     */
    async getSupporterRaw(requestParameters: GetSupporterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullGetSupporter>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupporter.');
        }

        if (requestParameters.supporterUserId === null || requestParameters.supporterUserId === undefined) {
            throw new runtime.RequiredError('supporterUserId','Required parameter requestParameters.supporterUserId was null or undefined when calling getSupporter.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporters/{supporter_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"supporter_user_id"}}`, encodeURIComponent(String(requestParameters.supporterUserId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullGetSupporterFromJSON(jsonValue));
    }

    /**
     * Gets the specified supporter of the given user
     */
    async getSupporter(requestParameters: GetSupporterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullGetSupporter> {
        const response = await this.getSupporterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the supporters of the given user
     */
    async getSupportersRaw(requestParameters: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullGetSupporters>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupporters.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullGetSupportersFromJSON(jsonValue));
    }

    /**
     * Gets the supporters of the given user
     */
    async getSupporters(requestParameters: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullGetSupporters> {
        const response = await this.getSupportersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the support from the given user to the supported user
     */
    async getSupportingRaw(requestParameters: GetSupportingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullGetSupporting>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupporting.');
        }

        if (requestParameters.supportedUserId === null || requestParameters.supportedUserId === undefined) {
            throw new runtime.RequiredError('supportedUserId','Required parameter requestParameters.supportedUserId was null or undefined when calling getSupporting.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporting/{supported_user_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"supported_user_id"}}`, encodeURIComponent(String(requestParameters.supportedUserId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullGetSupportingFromJSON(jsonValue));
    }

    /**
     * Gets the support from the given user to the supported user
     */
    async getSupporting(requestParameters: GetSupportingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullGetSupporting> {
        const response = await this.getSupportingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the users that the given user supports
     */
    async getSupportingsRaw(requestParameters: GetSupportingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullGetSupporting>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupportings.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullGetSupportingFromJSON(jsonValue));
    }

    /**
     * Gets the users that the given user supports
     */
    async getSupportings(requestParameters: GetSupportingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullGetSupporting> {
        const response = await this.getSupportingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get the Top Users having at least one track by follower count
     */
    async getTopUsersRaw(requestParameters: GetTopUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TopUsersResponseFull>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/top`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopUsersResponseFullFromJSON(jsonValue));
    }

    /**
     * Get the Top Users having at least one track by follower count
     */
    async getTopUsers(requestParameters: GetTopUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TopUsersResponseFull> {
        const response = await this.getTopUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get the Top Users for a Given Genre
     */
    async getTopUsersInGenreRaw(requestParameters: GetTopUsersInGenreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TopGenreUsersResponseFull>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.genre) {
            queryParameters['genre'] = requestParameters.genre;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/genre/top`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopGenreUsersResponseFullFromJSON(jsonValue));
    }

    /**
     * Get the Top Users for a Given Genre
     */
    async getTopUsersInGenre(requestParameters: GetTopUsersInGenreRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TopGenreUsersResponseFull> {
        const response = await this.getTopUsersInGenreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUserRaw(requestParameters: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullTracks>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTracksByUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = requestParameters.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
    }

    /**
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUser(requestParameters: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullTracks> {
        const response = await this.getTracksByUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the tracks created by a user using the user\'s handle
     */
    async getTracksByUserHandleRaw(requestParameters: GetTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullTracks>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getTracksByUserHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = requestParameters.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}/tracks`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullTracksFromJSON(jsonValue));
    }

    /**
     * Gets the tracks created by a user using the user\'s handle
     */
    async getTracksByUserHandle(requestParameters: GetTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullTracks> {
        const response = await this.getTracksByUserHandleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a single user by their user ID
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullUserResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullUserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their user ID
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullUserResponse> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a single user by their handle
     */
    async getUserByHandleRaw(requestParameters: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FullUserResponse>> {
        if (requestParameters.handle === null || requestParameters.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter requestParameters.handle was null or undefined when calling getUserByHandle.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(requestParameters.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FullUserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their handle
     */
    async getUserByHandle(requestParameters: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FullUserResponse> {
        const response = await this.getUserByHandleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */
    async getUserLibraryTracksRaw(requestParameters: GetUserLibraryTracksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoritesResponseFull>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUserLibraryTracks.');
        }

        if (requestParameters.encodedDataMessage === null || requestParameters.encodedDataMessage === undefined) {
            throw new runtime.RequiredError('encodedDataMessage','Required parameter requestParameters.encodedDataMessage was null or undefined when calling getUserLibraryTracks.');
        }

        if (requestParameters.encodedDataSignature === null || requestParameters.encodedDataSignature === undefined) {
            throw new runtime.RequiredError('encodedDataSignature','Required parameter requestParameters.encodedDataSignature was null or undefined when calling getUserLibraryTracks.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.encodedDataMessage !== undefined && requestParameters.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(requestParameters.encodedDataMessage);
        }

        if (requestParameters.encodedDataSignature !== undefined && requestParameters.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(requestParameters.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/library/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FavoritesResponseFullFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s saved/reposted/purchased/all tracks
     * Fetch a user\'s full library tracks
     */
    async getUserLibraryTracks(requestParameters: GetUserLibraryTracksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoritesResponseFull> {
        const response = await this.getUserLibraryTracksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Gets the user\'s replica set
     */
    async getUserReplicaSetRaw(requestParameters: GetUserReplicaSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersByContentNode>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUserReplicaSet.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/replica_set`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersByContentNodeFromJSON(jsonValue));
    }

    /**
     * Gets the user\'s replica set
     */
    async getUserReplicaSet(requestParameters: GetUserReplicaSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersByContentNode> {
        const response = await this.getUserReplicaSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /** @hidden
     * Get the tracks the user recently listened to.
     */
    async getUsersTrackHistoryRaw(requestParameters: GetUsersTrackHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HistoryResponseFull>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUsersTrackHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.sortMethod !== undefined) {
            queryParameters['sort_method'] = requestParameters.sortMethod;
        }

        if (requestParameters.sortDirection !== undefined) {
            queryParameters['sort_direction'] = requestParameters.sortDirection;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/history/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HistoryResponseFullFromJSON(jsonValue));
    }

    /**
     * Get the tracks the user recently listened to.
     */
    async getUsersTrackHistory(requestParameters: GetUsersTrackHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HistoryResponseFull> {
        const response = await this.getUsersTrackHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetAIAttributedTracksByUserHandleSortEnum = typeof GetAIAttributedTracksByUserHandleSortEnum[keyof typeof GetAIAttributedTracksByUserHandleSortEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Length: 'length',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetAIAttributedTracksByUserHandleSortMethodEnum = typeof GetAIAttributedTracksByUserHandleSortMethodEnum[keyof typeof GetAIAttributedTracksByUserHandleSortMethodEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAIAttributedTracksByUserHandleSortDirectionEnum = typeof GetAIAttributedTracksByUserHandleSortDirectionEnum[keyof typeof GetAIAttributedTracksByUserHandleSortDirectionEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetAIAttributedTracksByUserHandleFilterTracksEnum = typeof GetAIAttributedTracksByUserHandleFilterTracksEnum[keyof typeof GetAIAttributedTracksByUserHandleFilterTracksEnum];
/**
 * @export
 */
export const GetFavoritesSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Length: 'length',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetFavoritesSortMethodEnum = typeof GetFavoritesSortMethodEnum[keyof typeof GetFavoritesSortMethodEnum];
/**
 * @export
 */
export const GetFavoritesSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetFavoritesSortDirectionEnum = typeof GetFavoritesSortDirectionEnum[keyof typeof GetFavoritesSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetTracksByUserSortEnum = typeof GetTracksByUserSortEnum[keyof typeof GetTracksByUserSortEnum];
/**
 * @export
 */
export const GetTracksByUserSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Length: 'length',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetTracksByUserSortMethodEnum = typeof GetTracksByUserSortMethodEnum[keyof typeof GetTracksByUserSortMethodEnum];
/**
 * @export
 */
export const GetTracksByUserSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetTracksByUserSortDirectionEnum = typeof GetTracksByUserSortDirectionEnum[keyof typeof GetTracksByUserSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetTracksByUserFilterTracksEnum = typeof GetTracksByUserFilterTracksEnum[keyof typeof GetTracksByUserFilterTracksEnum];
/**
 * @export
 */
export const GetTracksByUserHandleSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetTracksByUserHandleSortEnum = typeof GetTracksByUserHandleSortEnum[keyof typeof GetTracksByUserHandleSortEnum];
/**
 * @export
 */
export const GetTracksByUserHandleSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Length: 'length',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetTracksByUserHandleSortMethodEnum = typeof GetTracksByUserHandleSortMethodEnum[keyof typeof GetTracksByUserHandleSortMethodEnum];
/**
 * @export
 */
export const GetTracksByUserHandleSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetTracksByUserHandleSortDirectionEnum = typeof GetTracksByUserHandleSortDirectionEnum[keyof typeof GetTracksByUserHandleSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserHandleFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetTracksByUserHandleFilterTracksEnum = typeof GetTracksByUserHandleFilterTracksEnum[keyof typeof GetTracksByUserHandleFilterTracksEnum];
/**
 * @export
 */
export const GetUserLibraryTracksSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Length: 'length',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetUserLibraryTracksSortMethodEnum = typeof GetUserLibraryTracksSortMethodEnum[keyof typeof GetUserLibraryTracksSortMethodEnum];
/**
 * @export
 */
export const GetUserLibraryTracksSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetUserLibraryTracksSortDirectionEnum = typeof GetUserLibraryTracksSortDirectionEnum[keyof typeof GetUserLibraryTracksSortDirectionEnum];
/**
 * @export
 */
export const GetUserLibraryTracksTypeEnum = {
    All: 'all',
    Repost: 'repost',
    Favorite: 'favorite',
    Purchase: 'purchase'
} as const;
export type GetUserLibraryTracksTypeEnum = typeof GetUserLibraryTracksTypeEnum[keyof typeof GetUserLibraryTracksTypeEnum];
/**
 * @export
 */
export const GetUsersTrackHistorySortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Length: 'length',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetUsersTrackHistorySortMethodEnum = typeof GetUsersTrackHistorySortMethodEnum[keyof typeof GetUsersTrackHistorySortMethodEnum];
/**
 * @export
 */
export const GetUsersTrackHistorySortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetUsersTrackHistorySortDirectionEnum = typeof GetUsersTrackHistorySortDirectionEnum[keyof typeof GetUsersTrackHistorySortDirectionEnum];
