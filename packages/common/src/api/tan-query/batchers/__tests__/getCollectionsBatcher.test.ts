import {
  full,
  GetBulkPlaylistsRequest,
  HashId,
  Id,
  OptionalId
} from '@audius/sdk'
import { QueryClient } from '@tanstack/react-query'
import { omit } from 'lodash'
import { describe, it, expect, beforeEach, vi, MockInstance } from 'vitest'

import { userCollectionMetadataFromSDK } from '~/adapters/collection'

import { getCollectionsBatcher } from '../getCollectionsBatcher'
import type { BatchContext } from '../types'

describe('getCollectionsBatcher', () => {
  const createMockSdkCollection = (id: number): full.PlaylistFull => ({
    id: Id.parse(id),
    userId: Id.parse(1),
    playlistName: `Test Collection ${id}`,
    description: '',
    artwork: {},
    isAlbum: false,
    isPrivate: false,
    isDelete: false,
    isStreamGated: false,
    isScheduledRelease: false,
    isImageAutogenerated: false,
    permalink: '',
    playlistContents: [],
    repostCount: 0,
    favoriteCount: 0,
    totalPlayCount: 0,
    trackCount: 0,
    blocknumber: 0,
    createdAt: '',
    updatedAt: '',
    followeeReposts: [],
    followeeFavorites: [],
    hasCurrentUserReposted: false,
    hasCurrentUserSaved: false,
    addedTimestamps: [],
    access: {
      stream: true,
      download: true
    },
    user: {
      albumCount: 0,
      artistPickTrackId: undefined,
      bio: '',
      coverPhoto: {
        _640x: '',
        _2000x: '',
        mirrors: []
      },
      followeeCount: 0,
      followerCount: 0,
      handle: 'test',
      id: Id.parse(1),
      isVerified: false,
      twitterHandle: '',
      instagramHandle: '',
      tiktokHandle: '',
      verifiedWithTwitter: false,
      verifiedWithInstagram: false,
      verifiedWithTiktok: false,
      website: '',
      donation: '',
      location: '',
      name: 'Test User',
      playlistCount: 0,
      profilePicture: {
        _150x150: '',
        _480x480: '',
        _1000x1000: '',
        mirrors: []
      },
      repostCount: 0,
      trackCount: 0,
      isDeactivated: false,
      isAvailable: true,
      ercWallet: '',
      splWallet: '',
      supporterCount: 0,
      supportingCount: 0,
      totalAudioBalance: 0,
      wallet: '',
      balance: '0',
      associatedWalletsBalance: '0',
      totalBalance: '0',
      waudioBalance: '0',
      associatedSolWalletsBalance: '0',
      blocknumber: 0,
      createdAt: '',
      isStorageV2: false,
      currentUserFolloweeFollowCount: 0,
      doesCurrentUserFollow: false,
      doesCurrentUserSubscribe: false,
      doesFollowCurrentUser: false,
      handleLc: 'test',
      updatedAt: '',
      coverPhotoSizes: '',
      coverPhotoCids: undefined,
      coverPhotoLegacy: undefined,
      profilePictureSizes: '',
      profilePictureCids: undefined,
      profilePictureLegacy: undefined,
      metadataMultihash: undefined,
      hasCollectibles: false,
      playlistLibrary: undefined,
      allowAiAttribution: false
    }
  })

  const mockSdk = {
    full: {
      playlists: {
        getBulkPlaylists: vi
          .fn()
          .mockImplementation((params: GetBulkPlaylistsRequest) => {
            const collections = params.id?.map((collectionId) =>
              createMockSdkCollection(HashId.parse(collectionId))
            )
            return Promise.resolve({ data: collections })
          })
      }
    }
  } as unknown as BatchContext['sdk']

  const mockContext: BatchContext = {
    sdk: mockSdk,
    currentUserId: null,
    queryClient: new QueryClient(),
    dispatch: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('fetches a single collection correctly', async () => {
    const batcher = getCollectionsBatcher(mockContext)
    const id = 1
    const result = await batcher.fetch(id)

    expect(mockSdk.full.playlists.getBulkPlaylists).toHaveBeenCalledWith({
      id: [Id.parse(id)],
      userId: OptionalId.parse(null)
    })
    expect(result).toMatchObject({
      ...(omit(
        userCollectionMetadataFromSDK(createMockSdkCollection(id)),
        'user',
        'tracks'
      ) ?? {})
    })
  })

  it('batches multiple collection requests and returns correct results to each caller', async () => {
    const batcher = getCollectionsBatcher(mockContext)
    const ids = [1, 2, 3]

    // Make concurrent requests
    const results = await Promise.all(ids.map((id) => batcher.fetch(id)))

    // Verify single bulk request was made
    expect(mockSdk.full.playlists.getBulkPlaylists).toHaveBeenCalledTimes(1)
    expect(mockSdk.full.playlists.getBulkPlaylists).toHaveBeenCalledWith({
      id: ids.map((id) => Id.parse(id)),
      userId: OptionalId.parse(null)
    })

    // Verify each caller got their correct collection data
    results.forEach((result, index) => {
      expect(result).toMatchObject({
        ...(omit(
          userCollectionMetadataFromSDK(createMockSdkCollection(ids[index])),
          'user',
          'tracks'
        ) ?? {})
      })
    })
  })

  it('creates separate batches when requests are not concurrent', async () => {
    const batcher = getCollectionsBatcher(mockContext)

    // First batch of requests
    const firstBatchIds = [1, 2]
    const firstBatchResults = await Promise.all(
      firstBatchIds.map((id) => batcher.fetch(id))
    )

    // Wait longer than the batch window
    await new Promise((resolve) => setTimeout(resolve, 20))

    // Second batch of requests
    const secondBatchIds = [3, 4]
    const secondBatchResults = await Promise.all(
      secondBatchIds.map((id) => batcher.fetch(id))
    )

    // Verify two separate bulk requests were made
    expect(mockSdk.full.playlists.getBulkPlaylists).toHaveBeenCalledTimes(2)
    expect(mockSdk.full.playlists.getBulkPlaylists).toHaveBeenNthCalledWith(1, {
      id: firstBatchIds.map((id) => Id.parse(id)),
      userId: OptionalId.parse(null)
    })
    expect(mockSdk.full.playlists.getBulkPlaylists).toHaveBeenNthCalledWith(2, {
      id: secondBatchIds.map((id) => Id.parse(id)),
      userId: OptionalId.parse(null)
    })

    // Verify results for first batch
    firstBatchResults.forEach((result, index) => {
      expect(result).toMatchObject({
        ...(omit(
          userCollectionMetadataFromSDK(
            createMockSdkCollection(firstBatchIds[index])
          ),
          'user',
          'tracks'
        ) ?? {})
      })
    })

    // Verify results for second batch
    secondBatchResults.forEach((result, index) => {
      expect(result).toMatchObject({
        ...(omit(
          userCollectionMetadataFromSDK(
            createMockSdkCollection(secondBatchIds[index])
          ),
          'user',
          'tracks'
        ) ?? {})
      })
    })
  })

  it('handles missing collections in batch response', async () => {
    const existingId = 1
    const missingId = 999

    // Mock API to only return data for existingId
    const mockBulkPlaylists = mockSdk.full.playlists
      .getBulkPlaylists as unknown as MockInstance<
      [GetBulkPlaylistsRequest],
      Promise<{ data: full.PlaylistFull[] }>
    >
    mockBulkPlaylists.mockImplementationOnce(
      (params: GetBulkPlaylistsRequest) => {
        const collections =
          params.id
            ?.filter((id) => HashId.parse(id) === existingId)
            .map((id) => createMockSdkCollection(HashId.parse(id))) ?? []
        return Promise.resolve({ data: collections })
      }
    )

    const batcher = getCollectionsBatcher(mockContext)
    const [missingResult, existingResult] = await Promise.all([
      batcher.fetch(missingId),
      batcher.fetch(existingId)
    ])

    // Verify existing collection is returned correctly
    expect(existingResult).toMatchObject({
      ...(omit(
        userCollectionMetadataFromSDK(createMockSdkCollection(existingId)),
        'user',
        'tracks'
      ) ?? {})
    })

    // Verify missing collection returns null
    expect(missingResult).toBeNull()

    // Verify single batch request was made with both IDs
    expect(mockSdk.full.playlists.getBulkPlaylists).toHaveBeenCalledTimes(1)
    expect(mockSdk.full.playlists.getBulkPlaylists).toHaveBeenCalledWith({
      id: [missingId, existingId].map((id) => Id.parse(id)),
      userId: OptionalId.parse(null)
    })
  })
})
