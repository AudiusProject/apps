import logging
from datetime import datetime, timedelta

import pytest

from integration_tests.utils import populate_mock_db
from src.queries.get_playlist_tracks import get_playlist_tracks
from src.queries.get_playlists import GetPlaylistsArgs, get_playlists
from src.utils.db_session import get_db

logger = logging.getLogger(__name__)


@pytest.fixture
def test_entities():
    return {
        "playlists": [
            {
                "playlist_id": 1,
                "playlist_owner_id": 1,
                "playlist_name": "playlist 1",
            },
            {
                "playlist_id": 2,
                "playlist_owner_id": 2,
                "playlist_name": "playlist 2",
                "is_private": True,
            },
            {
                "playlist_id": 3,
                "playlist_owner_id": 3,
                "playlist_name": "playlist 3",
                "is_current": True,
                "playlist_contents": {
                    "track_ids": [
                        {"track": 1},
                        {"track": 2},
                        {"track": 3},
                        {"track": 4},
                    ]
                },
            },
            {
                "playlist_id": 4,
                "playlist_owner_id": 3,
                "playlist_name": "playlist 4",
                "is_private": True,
                "is_current": True,
                "playlist_contents": {
                    "track_ids": [
                        {"track": 1},
                        {"track": 2},
                        {"track": 3},
                        {"track": 4},
                    ]
                },
            },
            {
                "playlist_id": 5,
                "playlist_owner_id": 3,
                "playlist_name": "playlist 5",
                "is_current": True,
                "is_image_autogenerated": True,
                "playlist_contents": {
                    "track_ids": [
                        {"track": 1},
                        {"track": 2},
                        {"track": 3},
                        {"track": 4},
                    ]
                },
            },
            {
                "playlist_id": 6,
                "playlist_owner_id": 1,
                "playlist_name": "playlist 6",
                "is_current": True,
                "is_image_autogenerated": True,
                "playlist_contents": {
                    "track_ids": [
                        {"track": 1},
                        {"track": 2},
                        {"track": 3},
                        {"track": 4},
                    ]
                },
            },
            {
                "playlist_id": 7,
                "playlist_owner_id": 1,
                "playlist_name": "album 7",
                "is_current": True,
                "is_album": True,
                "is_image_autogenerated": True,
                "playlist_contents": {
                    "track_ids": [
                        {"track": 1},
                        {"track": 2},
                        {"track": 3},
                        {"track": 4},
                    ]
                },
            },
        ],
        "users": [
            {"user_id": 1, "handle": "user1"},
            {"user_id": 2, "handle": "user2"},
            {"user_id": 3, "handle": "user3"},
        ],
        "playlist_routes": [
            {"slug": "playlist-1", "owner_id": 1, "playlist_id": 1},
            {"slug": "playlist-2", "owner_id": 2, "playlist_id": 2},
            {"slug": "playlist-3", "owner_id": 3, "playlist_id": 3},
            {"slug": "playlist-4", "owner_id": 3, "playlist_id": 4},
        ],
        "tracks": [
            {
                "track_id": 1,
                "title": "track 1",
                "owner_id": 1287289,
                "is_current": True,
                "release_date": datetime(2019, 12, 20),
                "created_at": datetime(2018, 5, 17),
            },
            {
                "track_id": 2,
                "title": "track 2",
                "owner_id": 1287289,
                "is_current": True,
                "created_at": datetime(2018, 5, 18),
            },
            {
                "track_id": 3,
                "title": "track 3",
                "owner_id": 1287289,
                "is_current": True,
                "release_date": datetime(2019, 12, 18),
                "created_at": datetime(2020, 5, 17),
                "is_unlisted": True,
            },
            {
                "track_id": 4,
                "title": "track 4",
                "owner_id": 1287289,
                "is_current": True,
                "release_date": "",
                "created_at": datetime(2018, 5, 19),
                "is_unlisted": True,
            },
        ],
    }


def assert_playlist(playlist, playlist_name, playlist_id, playlist_owner_id):
    assert playlist["playlist_name"] == playlist_name
    assert playlist["playlist_id"] == playlist_id
    assert playlist["playlist_owner_id"] == playlist_owner_id


def test_get_playlist_with_playlist_ids(app, test_entities):
    with app.test_request_context(
        # Request context and args are required for passing
        # pagination info into paginate_query inside get_playlists
        data={"limit": 5, "offset": 3},
    ):
        db = get_db()
        populate_mock_db(db, test_entities)
        with db.scoped_session():
            playlist = get_playlists(
                GetPlaylistsArgs(
                    current_user_id=2,
                    playlist_ids=[2],
                ),
            )

            assert len(playlist) == 1
            assert_playlist(
                playlist=playlist[0],
                playlist_id=2,
                playlist_name="playlist 2",
                playlist_owner_id=2,
            )


def test_get_private_playlist_with_playlist_ids(app, test_entities):
    with app.test_request_context(
        # Request context and args are required for passing
        # pagination info into paginate_query inside get_playlists
        data={"limit": 5, "offset": 3},
    ):
        db = get_db()
        populate_mock_db(db, test_entities)
        with db.scoped_session():
            playlist = get_playlists(
                GetPlaylistsArgs(
                    playlist_ids=[2],
                ),
            )

            assert len(playlist) == 1


def test_get_playlists_by_user_id(app, test_entities):
    with app.test_request_context(
        # Request context and args are required for passing
        # pagination info into paginate_query inside get_playlists
        data={"limit": 5, "offset": 3},
    ):
        db = get_db()
        populate_mock_db(db, test_entities)
        with db.scoped_session():
            playlist = get_playlists(
                GetPlaylistsArgs(
                    user_id=1,
                ),
            )
            assert len(playlist) == 3
            assert playlist[0]["playlist_id"] == 7
            assert playlist[1]["playlist_id"] == 6
            assert playlist[2]["playlist_id"] == 1
            playlist = get_playlists(
                GetPlaylistsArgs(user_id=1, kind="Playlist"),
            )
            assert len(playlist) == 2
            assert playlist[0]["playlist_id"] == 6
            assert playlist[1]["playlist_id"] == 1
            playlist = get_playlists(
                GetPlaylistsArgs(user_id=1, kind="Album"),
            )
            assert len(playlist) == 1
            assert playlist[0]["playlist_id"] == 7


def test_get_playlist_with_permalink(app, test_entities):
    with app.test_request_context(
        # Request context and args are required for passing
        # pagination info into paginate_query inside get_playlists
        data={"limit": 5, "offset": 3},
    ):
        db = get_db()
        populate_mock_db(db, test_entities)
        with db.scoped_session():
            playlist = get_playlists(
                GetPlaylistsArgs(
                    current_user_id=1,
                    routes=[{"handle": "user1", "slug": "playlist-1"}],
                ),
            )

            playlist_from_other_user = get_playlists(
                GetPlaylistsArgs(
                    current_user_id=2,
                    routes=[{"handle": "user1", "slug": "playlist-1"}],
                ),
            )
            assert len(playlist) == 1
            assert len(playlist_from_other_user) == 1
            assert playlist_from_other_user == playlist
            assert_playlist(
                playlist=playlist[0],
                playlist_id=1,
                playlist_name="playlist 1",
                playlist_owner_id=1,
            )


def test_get_playlist_with_permalink_private_playlist(app, test_entities):
    with app.test_request_context(
        # Request context and args are required for passing
        # pagination info into paginate_query inside get_playlists
        data={"limit": 5, "offset": 3},
    ):
        db = get_db()
        populate_mock_db(db, test_entities)
        with db.scoped_session():
            playlist = get_playlists(
                GetPlaylistsArgs(
                    current_user_id=1,
                    routes=[{"handle": "user2", "slug": "playlist-2"}],
                ),
            )
            assert len(playlist) == 1
            assert_playlist(
                playlist=playlist[0],
                playlist_id=2,
                playlist_name="playlist 2",
                playlist_owner_id=2,
            )


def test_get_playlist_with_listed_and_unlisted_tracks(app, test_entities):
    with app.test_request_context():
        db = get_db()
        populate_mock_db(db, test_entities)
        with db.scoped_session() as session:
            playlists = get_playlist_tracks(
                session, {"playlist_ids": [3, 4, 6], "current_user_id": 3}
            )
            assert len(playlists) == 3
            tracks_playlist_3 = playlists[3]
            tracks_playlist_4 = playlists[4]
            tracks_playlist_6 = playlists[6]

            # public with owner, has all four tracks
            assert len(tracks_playlist_3) == 4
            t1_p3, t2_p3, t3_p3, t4_p3 = tracks_playlist_3
            assert not t1_p3["is_unlisted"]
            assert not t2_p3["is_unlisted"]
            assert t3_p3["is_unlisted"]
            assert t4_p3["is_unlisted"]

            # public without owner, doesnt have all four tracks
            assert len(tracks_playlist_6) == 2
            t1_p6, t2_p6 = tracks_playlist_6
            assert not t1_p6["is_unlisted"]
            assert not t2_p6["is_unlisted"]

            # private, has all four tracks
            assert len(tracks_playlist_4) == 4
            t1_p4, t2_p4, t3_p4, t4_p4 = tracks_playlist_4
            assert not t1_p4["is_unlisted"]
            assert not t2_p4["is_unlisted"]
            assert t3_p4["is_unlisted"]
            assert t4_p4["is_unlisted"]


def test_get_playlist_with_autogenerated_image(app, test_entities):
    """Test getting playlists with autogenerated image"""

    with app.test_request_context():
        db = get_db()
        populate_mock_db(db, test_entities)

        with db.scoped_session():
            playlists = get_playlists(
                GetPlaylistsArgs(
                    current_user_id=3,
                    playlist_ids=[5],
                ),
            )
            assert len(playlists) == 1
            assert playlists[0]["is_image_autogenerated"] == True


def test_get_playlists_sorting(app, test_entities):
    """Test getting playlists with different sort methods"""
    # Add saves to test popularity sorting
    save_entities = {
        "saves": [
            # Make playlist 1 most popular with 3 saves
            {
                "user_id": 2,
                "save_type": "playlist",
                "save_item_id": 1,
            },
            {
                "user_id": 3,
                "save_type": "playlist",
                "save_item_id": 1,
            },
            # Give playlist 6 one save
            {
                "user_id": 2,
                "save_type": "playlist",
                "save_item_id": 6,
            },
        ]
    }

    with app.test_request_context():
        db = get_db()
        populate_mock_db(db, test_entities)
        populate_mock_db(db, save_entities)

        with db.scoped_session():
            # Test recent sorting (default)
            playlists_recent = get_playlists(
                GetPlaylistsArgs(user_id=1, sort_method="recent"),
            )
            assert len(playlists_recent) > 0
            # Most recently created should be first
            assert playlists_recent[0]["playlist_id"] == 7

            # Test popular sorting
            playlists_popular = get_playlists(
                GetPlaylistsArgs(user_id=1, sort_method="popular"),
            )
            assert len(playlists_popular) > 0
            # Most saved should be first (playlist 1 has 3 saves)
            assert playlists_popular[0]["playlist_id"] == 1
            # Second most saved should be second (playlist 2 has 1 save)
            assert playlists_popular[1]["playlist_id"] == 6


def test_get_playlists_default_and_invalid_sort(app, test_entities):
    """Test default sorting behavior and invalid sort methods"""
    # Add some test data with different creation timestamps
    test_entities["playlists"].extend(
        [
            {
                "playlist_id": 8,
                "playlist_owner_id": 1,
                "playlist_name": "newest playlist",
                "is_current": True,
                "created_at": datetime.now() + timedelta(days=1),
            },
            {
                "playlist_id": 9,
                "playlist_owner_id": 1,
                "playlist_name": "older playlist",
                "is_current": True,
                "created_at": datetime.now() - timedelta(days=1),
            },
        ]
    )

    with app.test_request_context():
        db = get_db()
        populate_mock_db(db, test_entities)

        with db.scoped_session():
            # Test default sorting (should be same as recent)
            playlists_default = get_playlists(
                GetPlaylistsArgs(user_id=1),
            )
            assert len(playlists_default) > 0
            # Most recently created should be first
            assert playlists_default[0]["playlist_id"] == 8

            # Test invalid sort method (should default to recent)
            playlists_invalid = get_playlists(
                GetPlaylistsArgs(user_id=1, sort_method="invalid_sort"),
            )
            assert len(playlists_invalid) > 0
            # Should match default sort order
            assert (
                playlists_invalid[0]["playlist_id"]
                == playlists_default[0]["playlist_id"]
            )
