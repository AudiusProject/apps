import { useState, useCallback } from 'react'

import { useGeneratePlaylistArtwork } from '@audius/common/hooks'
import { CollectionValues } from '@audius/common/schemas'
import { getErrorMessage } from '@audius/common/utils'
import { useField, useFormikContext } from 'formik'

import { HelperText } from 'components/data-entry/HelperText'
import { TrackEditFormValues } from 'components/edit-track/types'
import UploadArtwork, {
  UploadArtworkProps
} from 'components/upload/UploadArtwork'
import { resizeImage } from 'utils/imageProcessingUtil'

type ArtworkFieldProps = Partial<UploadArtworkProps> & {
  name: string
  size: 'small' | 'large'
  autoFocus?: boolean
}

export const ArtworkField = (props: ArtworkFieldProps) => {
  const { name, autoFocus, ...other } = props
  const { submitCount, initialValues } = useFormikContext<
    TrackEditFormValues | CollectionValues
  >()
  const [field, { touched, error }, { setValue }] = useField(name)
  const { value, ...otherField } = field
  const [
    { value: isImageAutogenerated },
    ,
    { setValue: setImageAutogenerated }
  ] = useField('is_image_autogenerated')
  const [, , { setValue: setCoverArtSizes }] = useField('cover_art_sizes')
  const [imageProcessingError, setImageProcessingError] = useState(false)
  const isUpload =
    'trackMetadatas' in initialValues
      ? initialValues?.trackMetadatas?.[0]?.track_id === undefined
      : !initialValues?.artwork?.url

  // Check if this is a collection (playlist/album) edit form
  const isCollectionEdit = 'playlist_id' in initialValues

  const collectionId = isCollectionEdit
    ? (initialValues as CollectionValues).playlist_id
    : null

  const generatePlaylistArtwork = useGeneratePlaylistArtwork(collectionId)

  const handleDropArtwork = async (selectedFiles: File[], source: string) => {
    try {
      let file = selectedFiles[0]
      file = await resizeImage(file)
      // @ts-ignore writing to read-only property. Maybe bugged?
      file.name = selectedFiles[0].name
      const url = URL.createObjectURL(file)
      setValue({ url, file, source })
      setImageAutogenerated(false)
      setImageProcessingError(false)
    } catch (err) {
      console.error(getErrorMessage(err))
      setImageProcessingError(true)
    }
  }

  const handleRemoveArtwork = useCallback(async () => {
    if (isCollectionEdit && !isUpload) {
      const isPlaylist = !(initialValues as CollectionValues).is_album

      if (isPlaylist && collectionId && generatePlaylistArtwork) {
        try {
          const artwork = await generatePlaylistArtwork()
          if (artwork) {
            setValue({ url: artwork.url, file: artwork.file })
            setImageAutogenerated(true)
            setCoverArtSizes(null)
            return
          }
        } catch (err) {
          console.error('Failed to generate auto artwork:', err)
        }

        setImageAutogenerated(true)
        setValue(null)
        setCoverArtSizes(null)
        return
      } else {
        setValue(null)
        return
      }
    }

    // For other cases (track editing, upload), just remove artwork
    if (!isUpload) {
      setValue(null)
    } else {
      // Type-safe access to initialValues[name]
      const initialValue = (initialValues as any)[name]
      setValue(initialValue)
    }
    setImageAutogenerated(true)
  }, [
    isCollectionEdit,
    isUpload,
    setValue,
    setImageAutogenerated,
    setCoverArtSizes,
    initialValues,
    name,
    generatePlaylistArtwork,
    collectionId
  ])

  const hasError = Boolean((touched || submitCount > 0) && error)

  return (
    <div>
      <UploadArtwork
        {...otherField}
        artworkUrl={value?.url}
        onDropArtwork={handleDropArtwork}
        imageProcessingError={imageProcessingError}
        {...other}
        isImageAutogenerated={isImageAutogenerated}
        onRemoveArtwork={handleRemoveArtwork}
        isUpload={isUpload}
        defaultPopupOpen={autoFocus}
      />
      {hasError ? <HelperText error={hasError}>{error}</HelperText> : null}
    </div>
  )
}
