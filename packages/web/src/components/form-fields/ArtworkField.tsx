import { useState, useCallback } from 'react'

import { EditCollectionValues } from '@audius/common/store'
import { getErrorMessage } from '@audius/common/utils'
import { useField, useFormikContext } from 'formik'

import { HelperText } from 'components/data-entry/HelperText'
import { TrackEditFormValues } from 'components/edit-track/types'
import UploadArtwork, {
  UploadArtworkProps
} from 'components/upload/UploadArtwork'
import { resizeImage } from 'utils/imageProcessingUtil'

type ArtworkFieldProps = Partial<UploadArtworkProps> & {
  name: string
  size: 'small' | 'large'
  autoFocus?: boolean
}

export const ArtworkField = (props: ArtworkFieldProps) => {
  const { name, autoFocus, ...other } = props
  const { submitCount, initialValues } = useFormikContext<
    TrackEditFormValues | EditCollectionValues
  >()
  const [field, { touched, error }, { setValue }] = useField(name)
  const { value, ...otherField } = field
  const [
    { value: isImageAutogenerated },
    ,
    { setValue: setImageAutogenerated }
  ] = useField('is_image_autogenerated')
  const [, , { setValue: setCoverArtSizes }] = useField('cover_art_sizes')
  const [imageProcessingError, setImageProcessingError] = useState(false)
  const isUpload =
    'trackMetadatas' in initialValues
      ? initialValues?.trackMetadatas?.[0]?.track_id === undefined
      : !initialValues?.artwork?.url

  // Check if this is a collection (playlist/album) edit form
  const isCollectionEdit = 'playlist_id' in initialValues

  const handleDropArtwork = async (selectedFiles: File[], source: string) => {
    try {
      let file = selectedFiles[0]
      file = await resizeImage(file)
      // @ts-ignore writing to read-only property. Maybe bugged?
      file.name = selectedFiles[0].name
      const url = URL.createObjectURL(file)
      setValue({ url, file, source })
      setImageAutogenerated(false)
      setImageProcessingError(false)
    } catch (err) {
      console.error(getErrorMessage(err))
      setImageProcessingError(true)
    }
  }

  const handleRemoveArtwork = useCallback(async () => {
    if (isCollectionEdit && !isUpload) {
      // Check if this is a playlist (not an album)
      const isPlaylist = !(initialValues as EditCollectionValues).is_album

      if (isPlaylist) {
        // For playlist editing, we'll let the form submission handle auto-generation
        // by setting is_image_autogenerated to true and clearing artwork, which will trigger the updatePlaylistArtwork
        // function in the edit saga to generate new artwork from tracks
        setImageAutogenerated(true)
        setValue(null)
        // Also clear cover_art_sizes to ensure auto-generation happens
        setCoverArtSizes(null)
        return
      } else {
        setValue(null)
        return
      }
    }

    // For other cases (track editing, upload), just remove artwork
    if (!isUpload) {
      setValue(null)
    } else {
      // Type-safe access to initialValues[name]
      const initialValue = (initialValues as any)[name]
      setValue(initialValue)
    }
    setImageAutogenerated(true)
  }, [
    isCollectionEdit,
    isUpload,
    setValue,
    setImageAutogenerated,
    setCoverArtSizes,
    initialValues,
    name
  ])

  const hasError = Boolean((touched || submitCount > 0) && error)

  return (
    <div>
      <UploadArtwork
        {...otherField}
        artworkUrl={value?.url}
        onDropArtwork={handleDropArtwork}
        imageProcessingError={imageProcessingError}
        {...other}
        isImageAutogenerated={isImageAutogenerated}
        onRemoveArtwork={handleRemoveArtwork}
        isUpload={isUpload}
        defaultPopupOpen={autoFocus}
      />
      {hasError ? <HelperText error={hasError}>{error}</HelperText> : null}
    </div>
  )
}
