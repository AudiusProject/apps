//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func main() {
	if len(os.Args) != 3 {
		fmt.Println("Usage: go run scripts/generate_options.go <struct name> <output file>")
		return
	}
	structName := os.Args[1]
	outputFile := os.Args[2]

	// Open the current directory and parse the package
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.AllErrors)
	if err != nil {
		panic(err)
	}

	var structType *ast.StructType
	var packageName string
	importsSet := make(map[string]struct{})
	usedImports := make(map[string]struct{})

	// Find the struct in the package
	for _, pkg := range pkgs {
		packageName = pkg.Name
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
					for _, spec := range genDecl.Specs {
						if typeSpec, ok := spec.(*ast.TypeSpec); ok && typeSpec.Name.Name == structName {
							if st, ok := typeSpec.Type.(*ast.StructType); ok {
								structType = st
							}
						}
					}
				}
			}
			for _, imp := range file.Imports {
				importsSet[imp.Path.Value] = struct{}{}
			}
		}
	}

	if structType == nil {
		fmt.Printf("Struct %s not found\n", structName)
		return
	}

	// Determine used imports
	for _, field := range structType.Fields.List {
		var fieldType strings.Builder
		if err := printer.Fprint(&fieldType, fset, field.Type); err != nil {
			panic(err)
		}
		typeStr := fieldType.String()
		for imp := range importsSet {
			if strings.Contains(typeStr, imp) {
				usedImports[imp] = struct{}{}
			}
		}
	}

	f, err := os.Create(outputFile)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by generate_options.go; DO NOT EDIT.\n")
	fmt.Fprintf(f, "// Auto-generated file for %s struct options pattern.\n\n", structName)
	fmt.Fprintf(f, "package %s\n\n", packageName)

	// Write the used imports
	if len(usedImports) > 0 {
		fmt.Fprintln(f, "import (")
		for imp := range usedImports {
			fmt.Fprintf(f, "\t%s\n", imp)
		}
		fmt.Fprintln(f, ")")
	}
	fmt.Fprintln(f)

	fmt.Fprintf(f, "type %sOption func(*%s)\n\n", structName, structName)
	fmt.Fprintf(f, "func New%s(opts ...%sOption) (*%s, error) {\n", structName, structName, structName)
	fmt.Fprintf(f, "\ts := default%s()\n", structName)
	fmt.Fprintln(f, "\tfor _, opt := range opts {")
	fmt.Fprintln(f, "\t\topt(s)")
	fmt.Fprintln(f, "\t}")
	fmt.Fprintf(f, "\tif err := init%s(s); err != nil {\n", structName)
	fmt.Fprintf(f, "\t\treturn nil, err\n")
	fmt.Fprintln(f, "\t}")
	fmt.Fprintln(f, "\treturn s, nil")
	fmt.Fprintln(f, "}")

	title := cases.Title(language.Und)
	for _, field := range structType.Fields.List {
		for _, fieldName := range field.Names {
			var fieldType strings.Builder
			if err := printer.Fprint(&fieldType, fset, field.Type); err != nil {
				panic(err)
			}
			optFunc := fmt.Sprintf("func With%s(%s %s) %sOption {\n",
				title.String(fieldName.Name), fieldName.Name, fieldType.String(), structName)
			optFunc += fmt.Sprintf("\treturn func(s *%s) {\n", structName)
			optFunc += fmt.Sprintf("\t\ts.%s = %s\n", fieldName.Name, fieldName.Name)
			optFunc += fmt.Sprintf("\t}\n")
			optFunc += "}\n\n"
			f.WriteString(optFunc)
		}
	}
}
